Project Summary for: .
Base Project Directory: C:\Users\Ty\source\repos\Personal-Profile\my-profile-website
Scanned Path: C:\Users\Ty\source\repos\Personal-Profile\my-profile-website

Folder Structure:

.git/ (ignored by SKIP_DIRECTORIES)
.vscode/
  launch.json
build/ (ignored by SKIP_DIRECTORIES)
compileProject.js
jsconfig.json
node_modules/ (ignored by SKIP_DIRECTORIES)
public/
  index.html
  manifest.json
  robots.txt
README.md
src/
  App.js
  components/
    AnimatedBackground.js
    PixelEnemy.css
    PixelEnemy.js
    PixelSprite.css
    PixelSprite.js
  Contact.js
  emails/
    index.js
  ForFunProjects.js
  game/
    abilities/
      abilityDefinitions.js
      AbilityManager.js
    components/
      GameCanvas.js
      GameOverScreen.js
      GameUI.js
      PauseScreen.js
      Shop.js
    constants/
      achievements.js
      gameConstants.js
      shopItems.js
    entities/
      Enemy.js
      Particle.js
      Player.js
      Powerup.js
      Projectile.js
    hooks/
      useAbilities.js
      useGameState.js
    rendering/
      EffectsRenderer.js
      GameRenderer.js
      UIRenderer.js
    systems/
      AchievementSystem.js
      CollisionSystem.js
      GameLoop.js
      InputHandler.js
      WaveSystem.js
    UltimatePixelGame.js
    utils/
      gameHelpers.js
      mathUtils.js
  Home.js
  index.css
  index.js
  LandingPage.js
  Navbar.js
  pictures/
    class_photos/
    porfolio_photos/
      animation_photos/
    sprite/
      EnemySprite/
      PixelSprite/
  Projects.js
  SchoolProjects.js
  Skills.js
  Testimonials.js
  UltimatePixelGame.js
  WorkProjects.js


---

Project Files Content:



---

File: .vscode\launch.json

{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "chrome",
            "request": "launch",
            "name": "Launch Chrome against localhost",
            "url": "http://localhost:8080",
            "webRoot": "${workspaceFolder}"
        }
    ]
}

---

File: compileProject.js

const fs = require('fs');
const path = require('path');

// Base project directory - KEEP THIS AS THE ABSOLUTE ROOT OF YOUR PROJECT
const baseProjectDir = 'C:\\Users\\Ty\\source\\repos\\Personal-Profile\\my-profile-website';
const outputFile = 'project_summary.txt';

// Configuration
const MAX_FILE_SIZE = 1024 * 1024; // 1MB limit
const RELEVANT_EXTENSIONS = [
  '.js', '.jsx', '.ts', '.tsx',  // JavaScript/TypeScript files
  '.html', '.css', '.scss',      // Web files
  '.json', '.md',                // Config and documentation
  '.txt'                         // Text files
];

const SKIP_FILES = [
  'node_modules',
  '.git',
  '.gitignore',
  'package-lock.json',
  'package.json',
  'project_summary.txt', // The output file itself
  '.map',  // Skip source map files
  'main.30bebfa5.css', // Skip the specific CSS file
];

const SKIP_DIRECTORIES = [
  'build',  // Skip the entire build directory
  'node_modules',
  '.git',
  'processed'  // Skip the processed directory entirely
];

const SKIP_CONTENTS_EXTENSIONS = [
  '.jpg', '.jpeg', '.png', '.gif', '.ico', '.svg',  // Images
  '.map',  // Source maps
  '.ttf', '.woff', '.woff2', '.eot'  // Fonts
];

// Additional patterns to skip chunk files specifically
const SKIP_PATTERNS = [
  /chunk\d+\.js$/,  // Skip any file matching "chunk" followed by numbers and .js
  /^chunk/          // Skip any file starting with "chunk"
];

const shouldSkipFile = (fileName, filePath) => {
  // Check if file matches skip patterns
  if (SKIP_PATTERNS.some(pattern => pattern.test(fileName))) {
    return true;
  }

  // Check if file is in skip files list
  if (SKIP_FILES.some(skip => fileName.includes(skip) || fileName === skip)) { // Added direct match for exact filenames
    return true;
  }

  // Check if file path contains "processed" anywhere in the path
  // This is a bit broad; consider if you only want to skip top-level "processed" directories.
  // For now, it matches the original logic.
  if (filePath.toLowerCase().includes(path.sep + 'processed' + path.sep) || filePath.toLowerCase().endsWith(path.sep + 'processed')) {
    return true;
  }

  return false;
};

const getAllFiles = (dirPath, arrayOfFiles = []) => {
  const dirName = path.basename(dirPath);

  // Skip entire directories based on SKIP_DIRECTORIES
  if (SKIP_DIRECTORIES.includes(dirName)) {
    console.log(`Skipping directory based on SKIP_DIRECTORIES: ${dirPath}`);
    return arrayOfFiles;
  }

  // Skip if directory path contains "processed" (more specific check)
  if (dirPath.toLowerCase().includes(path.sep + 'processed' + path.sep) || dirPath.toLowerCase().endsWith(path.sep + 'processed')) {
    console.log(`Skipping directory because it's a 'processed' path: ${dirPath}`);
    return arrayOfFiles;
  }

  let files;
  try {
    files = fs.readdirSync(dirPath);
  } catch (err) {
    console.error(`Error reading directory ${dirPath}: ${err.message}`);
    return arrayOfFiles; // Stop processing this path if unreadable
  }


  files.forEach((file) => {
    const fullPath = path.join(dirPath, file);

    // Check if the directory itself (the component of fullPath) should be skipped
    if (fs.statSync(fullPath).isDirectory()) {
        const currentDirName = path.basename(fullPath);
        if (SKIP_DIRECTORIES.includes(currentDirName)) {
            console.log(`Skipping directory component: ${fullPath}`);
            return;
        }
        // Recursive call for directories
        getAllFiles(fullPath, arrayOfFiles);
    } else {
        // File-specific checks
        if (shouldSkipFile(file, fullPath)) {
            console.log(`Skipping file: ${fullPath}`);
            return;
        }
        const ext = path.extname(file).toLowerCase();
        if (RELEVANT_EXTENSIONS.includes(ext)) {
            arrayOfFiles.push(fullPath);
        }
    }
  });

  return arrayOfFiles;
};

const getFilePreview = (filePath) => {
  const stats = fs.statSync(filePath);
  const extension = path.extname(filePath).toLowerCase();

  // Skip binary files and source maps
  if (SKIP_CONTENTS_EXTENSIONS.includes(extension)) {
    return `[${extension.substring(1)} file content skipped]`;
  }

  // Check file size
  if (stats.size > MAX_FILE_SIZE) {
    return `[File too large: ${(stats.size / (1024 * 1024)).toFixed(2)}MB, content skipped]`;
  }

  try {
    return fs.readFileSync(filePath, 'utf-8');
  } catch (error) {
    return `[Error reading file: ${error.message}]`;
  }
};

const compileProjectFiles = (scanDirPath, outputFilePath) => {
  console.log(`Scanning directory: ${scanDirPath}`);
  const filesToInclude = getAllFiles(scanDirPath);
  let content = `Project Summary for: ${path.relative(baseProjectDir, scanDirPath) || '.'}\n`;
  content += `Base Project Directory: ${baseProjectDir}\n`;
  content += `Scanned Path: ${scanDirPath}\n\n`;
  content += 'Folder Structure:\n\n';

  // Add folder structure relative to scanDirPath
  const addFolderStructure = (currentPath, indent = '') => {
    const currentDirName = path.basename(currentPath);

    // Skip directories listed in SKIP_DIRECTORIES
    if (SKIP_DIRECTORIES.includes(currentDirName) && currentPath !== scanDirPath) { // Don't skip the root scanDirPath itself if it's named like a skip_dir
      content += `${indent}${currentDirName}/ (ignored by SKIP_DIRECTORIES)\n`;
      console.log(`Folder Structure: Skipping directory ${currentPath} due to SKIP_DIRECTORIES`);
      return;
    }

    // Skip if directory path contains "processed"
    if ((currentPath.toLowerCase().includes(path.sep + 'processed' + path.sep) || currentPath.toLowerCase().endsWith(path.sep + 'processed')) && currentPath !== scanDirPath) {
        content += `${indent}${currentDirName}/ (ignored, 'processed' path)\n`;
        console.log(`Folder Structure: Skipping directory ${currentPath} because it's a 'processed' path`);
        return;
    }

    let items;
    try {
        items = fs.readdirSync(currentPath);
    } catch (err) {
        content += `${indent}${currentDirName}/ (Error reading: ${err.message})\n`;
        console.error(`Folder Structure: Error reading directory ${currentPath}: ${err.message}`);
        return;
    }


    items.forEach((item) => {
      const fullItemPath = path.join(currentPath, item);
      let itemStat;
      try {
        itemStat = fs.statSync(fullItemPath);
      } catch (e) {
        content += `${indent}${item} (Error stating file/dir)\n`;
        return;
      }

      if (itemStat.isDirectory()) {
        // Check if this directory itself should be skipped before recursing
        const subDirName = path.basename(fullItemPath);
        if (SKIP_DIRECTORIES.includes(subDirName)) {
          content += `${indent}${item}/ (ignored by SKIP_DIRECTORIES)\n`;
          console.log(`Folder Structure: Skipping sub-directory ${fullItemPath} due to SKIP_DIRECTORIES`);
          return;
        }
        if (fullItemPath.toLowerCase().includes(path.sep + 'processed' + path.sep) || fullItemPath.toLowerCase().endsWith(path.sep + 'processed')) {
            content += `${indent}${item}/ (ignored, 'processed' path)\n`;
            console.log(`Folder Structure: Skipping sub-directory ${fullItemPath} because it's a 'processed' path`);
            return;
        }
        if (shouldSkipFile(item, fullItemPath)) { // Using shouldSkipFile for directories too, if it makes sense (e.g. .git)
            content += `${indent}${item}/ (ignored by skip rules)\n`;
            console.log(`Folder Structure: Skipping directory ${fullItemPath} due to shouldSkipFile`);
            return;
        }
        content += `${indent}${item}/\n`;
        addFolderStructure(fullItemPath, indent + '  ');
      } else {
        if (shouldSkipFile(item, fullItemPath)) {
          // content += `${indent}${item} (ignored by skip rules)\n`; // Optionally show skipped files in structure
          return;
        }
        const ext = path.extname(item).toLowerCase();
        if (RELEVANT_EXTENSIONS.includes(ext)) {
            content += `${indent}${item}\n`;
        } else {
            // content += `${indent}${item} (irrelevant extension)\n`; // Optionally show non-relevant files
        }
      }
    });
  };

  addFolderStructure(scanDirPath);
  content += '\n\n---\n\nProject Files Content:\n\n';

  // Add file contents
  filesToInclude.forEach((file) => {
    // Make file path relative to the scanned directory for the output
    const relativePath = path.relative(scanDirPath, file);
    content += `\n\n---\n\nFile: ${relativePath}\n\n`;
    content += getFilePreview(file);
  });

  try {
    fs.writeFileSync(outputFilePath, content, 'utf-8');
    console.log(`Project files compiled into ${outputFilePath}`);
    console.log(`Total files included: ${filesToInclude.length}`);
  } catch (err) {
    console.error(`Error writing to output file ${outputFilePath}: ${err.message}`);
  }
};

// --- Main Execution ---
const targetSubFolder = process.argv[2]; // Get the folder name from the command line
let dirToScan;

if (targetSubFolder) {
  dirToScan = path.resolve(baseProjectDir, targetSubFolder); // Use resolve for robust path creation
  if (!fs.existsSync(dirToScan)) {
    console.error(`Error: The specified folder "${targetSubFolder}" does not exist inside "${baseProjectDir}".`);
    console.error(`Full path attempted: ${dirToScan}`);
    process.exit(1);
  }
  if (!fs.statSync(dirToScan).isDirectory()) {
    console.error(`Error: The specified path "${targetSubFolder}" is not a directory.`);
    console.error(`Full path attempted: ${dirToScan}`);
    process.exit(1);
  }
  console.log(`Targeting subfolder: ${targetSubFolder}`);
} else {
  dirToScan = path.resolve(baseProjectDir); // Default to base project directory
  console.log('No specific folder provided. Targeting the entire base project directory.');
}

const actualOutputFile = path.join(baseProjectDir, outputFile); // Output file in the base project directory

compileProjectFiles(dirToScan, actualOutputFile);

console.log("\nScript finished.");
console.log("Remember to check console logs for skipped files/directories if the output seems incomplete.");

---

File: jsconfig.json

{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src"
  },
  "include": [
    "src/**/*.js",
    "src/**/*.jsx"
  ],
  "exclude": [
    "node_modules",
    "build",
    "src/music"
  ]
}

---

File: public\index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <title>Ty Ty Time</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


---

File: public\manifest.json

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


---

File: public\robots.txt

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


---

File: README.md

# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


---

File: src\App.js

//import './App.css';
import { BrowserRouter, Route, Routes, Navigate } from "react-router-dom";
import Navbar from './Navbar';
import Home from './Home';
import LandingPage from './LandingPage';
import Skills from './Skills';
import Projects from './Projects';
import WorkProjects from './WorkProjects';
import SchoolProjects from './SchoolProjects';
import Testimonials from './Testimonials';
import Contact from './Contact';
import AnimatedBackground from './components/AnimatedBackground.js';
import UltimatePixelGame from './game/UltimatePixelGame'; 
import "bootstrap/dist/css/bootstrap.min.css";
import "bootstrap/dist/js/bootstrap.bundle.min.js";
import './index.css';
import picture from './pictures/porfolio_photos/imgonline-com-ua-TextureSeamless-JCI8TaR1FBycHm.jpg';

const LandingPageContainer = () => (
  <div className="LandingPage-container" style={{backgroundImage: `url(${picture})`}}>
    <AnimatedBackground />
    <LandingPage />
  </div>
);

const DefaultContainer = () => (
  <div style={{backgroundImage: `url(${picture})`}}>
    <Navbar />
      <Routes>
        <Route exact path="/Home" element={<Home />} />
        <Route exact path="/Skills" element={<Skills />} />
        <Route exact path="/Projects" element={<Projects />} />
        <Route exact path="/Testimonials" element={<Testimonials />} />
        <Route exact path="/Contact" element={<Contact />} />
        <Route exact path="/WorkProjects" element={<WorkProjects />} />
        <Route exact path="/SchoolProjects" element={<SchoolProjects />} />
        <Route exact path="/UltimatePixelGame" element={<UltimatePixelGame />} />
      </Routes>
  </div>
);


function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route exact path="/LandingPage" element={<LandingPageContainer />} />
        <Route exact path="/" element={<LandingPageContainer />} />
        <Route path="*" element={<DefaultContainer />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;


---

File: src\components\AnimatedBackground.js

import React from 'react';
import image1 from '../pictures/porfolio_photos/animation_photos/image1.png';
import image3 from '../pictures/porfolio_photos/animation_photos/image3.png';
import image4 from '../pictures/porfolio_photos/animation_photos/image4.png';
import image5 from '../pictures/porfolio_photos/animation_photos/image5.png';

const AnimatedBackground = () => {
  return (
    <div className="animated-background">
      <div className="sliding-background"></div>
      <div className="sliding-background second"></div>
      <div className="overlay"></div>
      <style>{`
        .animated-background {
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
          z-index: 10;
          opacity: 0.7;
        }

        .sliding-background {
          position: absolute;
          top: 0;
          left: 0;
          width: 400vw;
          height: 100vh;
          background: linear-gradient(45deg, 
            rgba(0, 0, 0, 0.6), 
            rgba(0, 0, 0, 0.4)
          ),
          url(${image1}) 0 0,
          url(${image3}) 100vw 0,
          url(${image4}) 200vw 0,
          url(${image5}) 300vw 0;
          background-size: contain;
          background-repeat: no-repeat;
          animation: slide 40s linear infinite;
        }

        .sliding-background.second {
          left: 400vw;
        }

        .overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            to right,
            rgba(128, 103, 67, 0.65),
            rgba(188, 163, 127, 0.55)
          );
        }

        @keyframes slide {
          0% {
            transform: translateX(0);
          }
          100% {
            transform: translateX(-400vw);
          }
        }

        .animated-background::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(
            to right,
            rgba(0, 0, 0, 0.2) 0%,
            rgba(0, 0, 0, 0) 5%,
            rgba(0, 0, 0, 0) 95%,
            rgba(0, 0, 0, 0.2) 100%
          );
        }
      `}</style>
    </div>
  );
};

export default AnimatedBackground;

---

File: src\components\PixelEnemy.css

.enemy {
    position: absolute;
    width: 30px;
    height: 30px;
    background-image: url('../pictures/sprite/EnemySprite/enemy.png');
    background-size: 120px 240px;
    background-repeat: no-repeat;
    pointer-events: none;
    will-change: transform;
    z-index: 998; 
  }
  
  .enemy.walk.down[data-frame="0"] { background-position: 0 0; }
  .enemy.walk.down[data-frame="1"] { background-position: -30px 0; }
  .enemy.walk.down[data-frame="2"] { background-position: -60px 0; }
  .enemy.walk.down[data-frame="3"] { background-position: -90px 0; }

  .enemy.walk.right[data-frame="0"] { background-position: 0 -48px; }
  .enemy.walk.right[data-frame="1"] { background-position: -30px -48px; }
  .enemy.walk.right[data-frame="2"] { background-position: -60px -48px; }
  .enemy.walk.right[data-frame="3"] { background-position: -90px -48px; }
  
  .enemy.walk.up[data-frame="0"] { background-position: 0 -95px; }
  .enemy.walk.up[data-frame="1"] { background-position: -30px -95px; }
  .enemy.walk.up[data-frame="2"] { background-position: -60px -95px; }
  .enemy.walk.up[data-frame="3"] { background-position: -90px -95px; }
  
  .enemy.walk.left[data-frame="0"] { background-position: 0 -144px; }
  .enemy.walk.left[data-frame="1"] { background-position: -30px -144px; }
  .enemy.walk.left[data-frame="2"] { background-position: -60px -144px; }
  .enemy.walk.left[data-frame="3"] { background-position: -90px -144px; }

  .enemy.death[data-frame="0"] { background-position: 0 -175px; }
  .enemy.death[data-frame="1"] { background-position: -30px -175px; }
  .enemy.death[data-frame="2"] { background-position: -60px -175px; }
  .enemy.death[data-frame="3"] { background-position: -90px -175px; }

---

File: src\components\PixelEnemy.js

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './PixelEnemy.css';

// Use React.memo without a comparison function so enemies always update
const PixelEnemy = ({ playerPos, reportPosition, onDefeated, id }) => {
  // Enemy state
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isActive, setIsActive] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  
  // Animation state
  const [direction, setDirection] = useState('down');
  const [animFrame, setAnimFrame] = useState(0);
  
  // Death animation state
  const [isDying, setIsDying] = useState(false);
  
  // Ref to track if defeat has been triggered to prevent multiple calls
  const isBeingDefeatedRef = useRef(false);
  const animationFrameIdRef = useRef(null);
  const deathAnimationTimerRef = useRef(null);
  const speedRef = useRef(2); // pixels per frame
  
  // Set initial random position
  useEffect(() => {
    // Start at a random edge of the screen
    const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
    let x, y;
    
    switch(side) {
      case 0: // top
        x = Math.random() * window.innerWidth;
        y = -30;
        setDirection('down');
        break;
      case 1: // right
        x = window.innerWidth + 30;
        y = Math.random() * window.innerHeight;
        setDirection('left');
        break;
      case 2: // bottom
        x = Math.random() * window.innerWidth;
        y = window.innerHeight + 30;
        setDirection('up');
        break;
      case 3: // left
        x = -30;
        y = Math.random() * window.innerHeight;
        setDirection('right');
        break;
      default:
        x = 0;
        y = 0;
        setDirection('down');
    }
    
    setPosition({ x, y });
    setIsInitialized(true);
  }, []);
  
  // Handle animation frames for walking
  useEffect(() => {
    if (!isActive || !isInitialized || isDying) return;
    
    const animationInterval = setInterval(() => {
      setAnimFrame(prev => (prev + 1) % 4);
    }, 150); // Animation frame rate
    
    return () => clearInterval(animationInterval);
  }, [isActive, isInitialized, isDying]);
  
  // Play death animation
  const playDeathAnimation = useCallback(() => {
    setIsDying(true);
    
    // Start death animation
    setAnimFrame(0);
    
    const advanceDeathFrame = (frame) => {
      if (frame >= 4) {
        // Animation complete, notify parent component
        if (typeof onDefeated === 'function') {
          onDefeated(id);
        }
        return;
      }
      
      setAnimFrame(frame);
      
      // Schedule next frame
      deathAnimationTimerRef.current = setTimeout(() => {
        advanceDeathFrame(frame + 1);
      }, 150); // 150ms per frame
    };
    
    // Start the death animation
    advanceDeathFrame(0);
  }, [id, onDefeated]);
  
  // Check for player attack with useCallback for better performance
  const checkForDefeat = useCallback((distance) => {
    const attackRange = 50;
    if (distance < attackRange && playerPos.isAttacking && !isBeingDefeatedRef.current) {
      isBeingDefeatedRef.current = true;
      
      // Cancel movement animation frame
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
      
      // Play death animation
      playDeathAnimation();
    }
  }, [playerPos.isAttacking, playDeathAnimation]);
  
  // Simplified direct movement approach
  useEffect(() => {
    if (!isActive || !isInitialized || isDying) return;
    
    const moveEnemy = () => {
      // Calculate direction to player
      const dx = playerPos.x - position.x;
      const dy = playerPos.y - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > 1) { // Only move if we're not already at the target
        // Update movement direction based on angle to player
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        
        // Determine direction based on angle
        // Convert angle to 4-direction system
        if (angle >= -45 && angle < 45) {
          setDirection('right');
        } else if (angle >= 45 && angle < 135) {
          setDirection('down');
        } else if (angle >= -135 && angle < -45) {
          setDirection('up');
        } else {
          setDirection('left');
        }
        
        // Calculate new position with speed adjustment
        const speedFactor = Math.min(speedRef.current, distance) / distance;
        const newX = position.x + dx * speedFactor;
        const newY = position.y + dy * speedFactor;
        
        // Update position
        setPosition({ x: newX, y: newY });
        
        // Report position to parent for centralized collision detection
        reportPosition(id, { x: newX, y: newY });
        
        // Check for player attack
        checkForDefeat(distance);
      }
      
      // Continue animation if still active
      if (isActive && !isDying) {
        animationFrameIdRef.current = requestAnimationFrame(moveEnemy);
      }
    };
    
    // Start the animation loop
    animationFrameIdRef.current = requestAnimationFrame(moveEnemy);
    
    return () => {
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
    };
  }, [isActive, isInitialized, isDying, playerPos, id, reportPosition, checkForDefeat, position]);
  
  // Clean up any lingering timers on unmount
  useEffect(() => {
    return () => {
      if (animationFrameIdRef.current) {
        cancelAnimationFrame(animationFrameIdRef.current);
      }
      if (deathAnimationTimerRef.current) {
        clearTimeout(deathAnimationTimerRef.current);
      }
    };
  }, []);
  
  // Skip rendering if not active
  if (!isActive) {
    return null;
  }
  
  return (
    <div 
      className={`enemy ${isDying ? 'death' : 'walk'} ${!isDying ? direction : ''}`}
      data-frame={animFrame}
      style={{
        transform: `translate(${position.x - 15}px, ${position.y - 30}px)`
      }}
    />
  );
};

export default React.memo(PixelEnemy);

---

File: src\components\PixelSprite.css

  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #bca37f; /* Match your portfolio palette */
    border-radius: 50%;
    transition: opacity 0.5s ease;
  }

  .sprite-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh; 
    pointer-events: none;
    z-index: 999;
    overflow: hidden; /* Prevent scrolling */
  }
  
  .sprite {
    position: absolute;
    width: 30px;
    height: 30px;
    background-image: url('../pictures/sprite/PixelSprite/character.png');
    background-size: 512px 256px; /* 4 columns x 32px, 4 rows x 32px */
    background-repeat: no-repeat;
    pointer-events: auto;
    will-change: transform; /* Hint for hardware acceleration */
    z-index: 999;
  }
   
/* Idle Animation (4 frames) */
.sprite.idle[data-frame="0"] { background-position: 0 0; }
.sprite.idle[data-frame="1"] { background-position: -30px 0; }
.sprite.idle[data-frame="2"] { background-position: -60px 0; }
.sprite.idle[data-frame="3"] { background-position: -90px 0; }
 
/* WalkLeft Animation (4 frames) */
.sprite.walkLeft[data-frame="0"] { background-position: 0 -92px; }
.sprite.walkLeft[data-frame="1"] { background-position: -30px -92px; }
.sprite.walkLeft[data-frame="2"] { background-position: -60px -92px; }
.sprite.walkLeft[data-frame="3"] { background-position: -90px -92px; }

/* WalkRight Animation (4 frames) */
.sprite.walkRight[data-frame="0"] { background-position: 0 -30px; }
.sprite.walkRight[data-frame="1"] { background-position: -30px -30px; } 
.sprite.walkRight[data-frame="2"] { background-position: -60px -30px; }
.sprite.walkRight[data-frame="3"] { background-position: -90px -30px; }

/* Jump Animation (3 frames) */ 
.sprite.jump[data-frame="0"] { background-position: -149px 0; }
.sprite.jump[data-frame="1"] { background-position: -179px 0; }
.sprite.jump[data-frame="2"] { background-position: -209px 0; }

/* floating in air (4 frames) */
.sprite.jump[data-frame="3"] { background-position: -269px 0; }
.sprite.jump[data-frame="4"] { background-position: -299px 0; }
.sprite.jump[data-frame="5"] { background-position: -329px 0; }
.sprite.jump[data-frame="6"] { background-position: -359px 0; }

/* touch ground from jump(1 frames) */
.sprite.jump[data-frame="7"] { background-position: -406px 0; }
  
/* Attack Animation (4 frames) */
.sprite.attack[data-frame="0"] { background-position: -13px -127px; }
.sprite.attack[data-frame="1"] { background-position: -73px -127px; }
.sprite.attack[data-frame="2"] { background-position: -133px -127px; }
.sprite.attack[data-frame="3"] { background-position: -193px -127px; }

.sprite.die[data-frame="0"] { background-position: -271px -125px; }
.sprite.die[data-frame="1"] { background-position: -301px -125px; }
.sprite.die[data-frame="2"] { background-position: -328px -125px; }  
.sprite.die[data-frame="3"] { background-position: -357px -125px; }
.sprite.die[data-frame="4"] { background-position: -386px -125px; }   
.sprite.die[data-frame="5"] { background-position: -413px -125px; }
.sprite.die[data-frame="6"] { background-position: -441px -125px; }
.sprite.die[data-frame="7"] { background-position: -441px  -125px; }

  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #bca37f;
    border-radius: 50%;
    will-change: transform, opacity; /* Hint for hardware acceleration */
    transition: opacity 0.2s linear; /* Faster fade for performance */
  }

  /* Game UI */
.game-ui {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 1000;
  pointer-events: none;
  font-family: 'Press Start 2P', monospace; /* Use a pixel font if available */
  color: white;
  text-shadow: 2px 2px 0 #000;
}

.health-bar {
  width: 200px;
  height: 20px;
  background-color: #333;
  border: 3px solid #111;
  border-radius: 4px;
  margin-bottom: 10px;
  overflow: hidden;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
}

.health-bar-inner {
  height: 100%;
  background-image: linear-gradient(to right, #ff0000, #ff6600);
  transition: width 0.3s ease-out;
}

.score {
  font-size: 16px;
  margin-bottom: 10px;
}

/* Game Over Screen with pointer-events fix */
.game-over {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 30px;
  border-radius: 10px;
  text-align: center;
  z-index: 1001;
  font-family: 'Press Start 2P', monospace;
  pointer-events: auto; /* Ensure clicks are captured */
}

.game-over h2 {
  font-size: 24px;
  margin-bottom: 20px;
  color: #ff0000;
}

.game-over button {
  margin-top: 20px;
  padding: 10px 20px;
  background-color: #ff6600;
  border: none;
  border-radius: 5px;
  color: white;
  font-family: inherit;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  pointer-events: auto; /* Ensure button clicks work */
}

.game-over button:hover {
  background-color: #ff9900;
}

/* Make player sprite on top */
.sprite {
  z-index: 999;
}

---

File: src\components\PixelSprite.js

import React, { useState, useEffect, useRef, useCallback } from 'react';
import './PixelSprite.css';
import PixelEnemy from './PixelEnemy';

const PixelSprite = () => {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [spritePos, setSpritePos] = useState({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
  const [enemyPositions, setEnemyPositions] = useState({});
  
  // Combined animation state
  const [animation, setAnimation] = useState({
    type: 'idle',
    frame: 0,
    isPlaying: false
  });
  
  // Jump offset and health
  const [jumpOffset, setJumpOffset] = useState(0);
  const [health, setHealth] = useState(100);
  const [score, setScore] = useState(0);
  
  // Track enemies
  const [enemies, setEnemies] = useState([]);
  
  // Last hit time to implement immunity period
  const lastHitTimeRef = useRef(0);
  
  const [particles, setParticles] = useState([]);
  const spriteRef = useRef(null);
  
  // Animation timer refs
  const animationTimerRef = useRef(null);
  
  // Enemy spawn timer
  const enemySpawnTimerRef = useRef(null);

  const isImmuneRef = useRef(false);
  
  // Game state
  const [gameActive, setGameActive] = useState(true);
  
  // Death animation state
  const [isDying, setIsDying] = useState(false);
  
  // Restart game function
  const handleRestart = useCallback(() => {
    // Reset player state
    setHealth(100);
    setScore(0);
    
    // Clear all enemies
    setEnemies([]);
    setEnemyPositions({});
    
    // Reset player position to center
    setSpritePos({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
    
    // Reset animation state
    setAnimation({
      type: 'idle',
      frame: 0,
      isPlaying: false
    });
    
    // Reset jump offset
    setJumpOffset(0);
    
    // Clear particles
    setParticles([]);
    
    // Reset immunity
    isImmuneRef.current = false;
    
    // Reset death state
    setIsDying(false);
    
    // Set game as active
    setGameActive(true);
    
    // Restart enemy spawning
    if (enemySpawnTimerRef.current) {
      clearTimeout(enemySpawnTimerRef.current);
    }
    enemySpawnTimerRef.current = setTimeout(() => {
      spawnEnemy();
    }, 2000);
  }, []);
  
  // Throttle mouse move events
  useEffect(() => {
    let lastUpdate = 0;
    const handleMouseMove = (e) => {
      // Only process mouse movements when game is active
      if (!gameActive || isDying) return;
      
      const now = performance.now();
      if (now - lastUpdate > 16) {
        setMousePos({ x: e.clientX, y: e.clientY });
        lastUpdate = now;
      }
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, [gameActive, isDying]);

  // Handle keyboard events (Space for jump)
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (!gameActive || isDying) return;
      
      if (e.code === 'Space' && !animation.isPlaying) {
        e.preventDefault();
        playJumpAnimation();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [animation.isPlaying, gameActive, isDying]);

  // Handle global click for attack
  useEffect(() => {
    const handleGlobalClick = (e) => {
      if (!gameActive || isDying) return;
      
      if (e.button === 0 && !animation.isPlaying) {
        playAnimation('attack', 4, 125);
      }
    };
    
    window.addEventListener('click', handleGlobalClick);
    return () => window.removeEventListener('click', handleGlobalClick);
  }, [animation.isPlaying, gameActive, isDying]);

  // Spawn enemies periodically
  const spawnEnemy = useCallback(() => {
    if (!gameActive) return;
    
    // Add a new enemy with unique ID
    setEnemies(prev => [
      ...prev, 
      { id: Date.now() }
    ]);
    
    // Schedule next spawn (random interval between 3-8 seconds)
    const nextSpawnTime = 3000 + Math.random() * 5000;
    enemySpawnTimerRef.current = setTimeout(spawnEnemy, nextSpawnTime);
  }, [gameActive]);
  
  useEffect(() => {
    // Initial spawn
    enemySpawnTimerRef.current = setTimeout(spawnEnemy, 2000);
    
    return () => clearTimeout(enemySpawnTimerRef.current);
  }, [spawnEnemy]);

  // Clean up any lingering timers on unmount
  useEffect(() => {
    return () => {
      clearTimeout(animationTimerRef.current);
      clearTimeout(enemySpawnTimerRef.current);
    };
  }, []);

  // Play the death animation
  const playDeathAnimation = () => {
    setIsDying(true);
    clearTimeout(animationTimerRef.current);
    
    setAnimation({
      type: 'die',
      frame: 0,
      isPlaying: true
    });
    
    const frameCount = 7; // 0-6 frames
    const frameDuration = 150; // milliseconds per frame
    let currentFrame = 0;
    
    const advanceFrame = () => {
      currentFrame++;
      
      if (currentFrame >= frameCount) {
        // End of animation - game over
        setAnimation({
          type: 'die',
          frame: 6, // Keep on last frame
          isPlaying: false
        });
        
        setGameActive(false);
        return;
      }
      
      // Update with the new frame number
      setAnimation(prev => ({
        ...prev,
        frame: currentFrame
      }));
      
      // Schedule next frame
      animationTimerRef.current = setTimeout(advanceFrame, frameDuration);
    };
    
    // Start the animation sequence
    animationTimerRef.current = setTimeout(advanceFrame, frameDuration);
  };

  const handlePlayerHit = () => {
    if (isImmuneRef.current || isDying) {
      return;
    }
    
    isImmuneRef.current = true;
    lastHitTimeRef.current = Date.now();
    
    setHealth(prev => {
      const newHealth = Math.max(0, prev - 50);
      
      // If health reaches zero, trigger death animation
      if (newHealth <= 0 && !isDying) {
        playDeathAnimation();
      }
      
      return newHealth;
    });
    
    setTimeout(() => {
      isImmuneRef.current = false;
    }, 1000);
  };
  
  const handleEnemyDefeated = (enemyId) => {
    setEnemies(prev => prev.filter(enemy => enemy.id !== enemyId));
    
    setEnemyPositions(prev => {
      const newPositions = {...prev};
      delete newPositions[enemyId];
      return newPositions;
    });
    
    setScore(prev => prev + 100);
  };

  // Special jump animation with vertical motion
  const playJumpAnimation = () => {
    clearTimeout(animationTimerRef.current);
    
    setAnimation({
      type: 'jump',
      frame: 0,
      isPlaying: true
    });
    
    // Jump parameters
    const frameCount = 8;
    const frameDuration = 100;
    let currentFrame = 0;
    
    // Jump height curve (parabola)
    const jumpHeights = [0, -15, -25, -30, -30, -25, -15, 0];
    
    const advanceJumpFrame = () => {
      currentFrame++;
      
      if (currentFrame >= frameCount) {
        // End of animation
        setAnimation({
          type: 'idle',
          frame: 0,
          isPlaying: false
        });
        setJumpOffset(0); // Reset jump height
        return;
      }
      
      // Update jump height
      setJumpOffset(jumpHeights[currentFrame]);
      
      // Update animation frame
      setAnimation(prev => ({
        ...prev,
        frame: currentFrame
      }));
      
      // Schedule next frame
      animationTimerRef.current = setTimeout(advanceJumpFrame, frameDuration);
    };
    
    // Start the animation sequence
    animationTimerRef.current = setTimeout(advanceJumpFrame, frameDuration);
  };
  
  // Standard animation player for non-jump animations
  const playAnimation = (type, frameCount, frameDuration) => {
    clearTimeout(animationTimerRef.current);
    
    setAnimation({
      type,
      frame: 0,
      isPlaying: true
    });
    
    let currentFrame = 0;
    
    const advanceFrame = () => {
      currentFrame++;
      
      if (currentFrame >= frameCount) {
        // End of animation
        setAnimation({
          type: 'idle',
          frame: 0,
          isPlaying: false
        });
        return;
      }
      
      // Update with the new frame number
      setAnimation(prev => ({
        ...prev,
        frame: currentFrame
      }));
      
      // Schedule next frame
      animationTimerRef.current = setTimeout(advanceFrame, frameDuration);
    };
    
    // Start the animation sequence
    animationTimerRef.current = setTimeout(advanceFrame, frameDuration);
  };
  
  // Cycle idle/walk animations
  useEffect(() => {
    if (!animation.isPlaying && gameActive && !isDying) {
      const cycleDuration = 125; // ms per frame
      
      const cycleIdleWalkFrames = () => {
        setAnimation(prev => ({
          ...prev,
          frame: (prev.frame + 1) % 4 // Cycle 0-3 for idle/walk
        }));
      };
      
      const timerId = setInterval(cycleIdleWalkFrames, cycleDuration);
      return () => clearInterval(timerId);
    }
  }, [animation.isPlaying, gameActive, isDying]);

  // Movement and state detection
  useEffect(() => {
    if (!gameActive || isDying) return;
    
    let animationFrameId;
    const MAX_PARTICLES = 20;

    const update = () => {
      setSpritePos((prev) => {
        const dx = mousePos.x - prev.x;
        const dy = mousePos.y - prev.y;
        const speed = 0.1;
        const newX = prev.x + dx * speed;
        const newY = prev.y + dy * speed;

        // Only update movement-based states when not in a special animation
        if (!animation.isPlaying) {
          if (Math.abs(dx) > 5) {
            setAnimation(prev => ({
              ...prev,
              type: dx > 0 ? 'walkRight' : 'walkLeft'
            }));
          } else {
            setAnimation(prev => ({
              ...prev,
              type: 'idle'
            }));
          }
        }

        // Add particle
        if (particles.length < MAX_PARTICLES && Math.random() > 0.9) {
          setParticles((prev) => [
            ...prev.slice(-MAX_PARTICLES + 1),
            { x: newX, y: newY, life: 1 },
          ]);
        }

        return { x: newX, y: newY };
      });

      // Update particles
      setParticles((prev) =>
        prev.map((p) => ({ ...p, life: p.life - 0.05 })).filter((p) => p.life > 0)
      );

      animationFrameId = requestAnimationFrame(update);
    };

    animationFrameId = requestAnimationFrame(update);
    return () => cancelAnimationFrame(animationFrameId);
  }, [mousePos, particles.length, animation.isPlaying, gameActive, isDying]);

  const reportEnemyPosition = (enemyId, position) => {
    setEnemyPositions(prev => ({
      ...prev,
      [enemyId]: position
    }));
  };

  // Centralized collision detection
  useEffect(() => {
    if (!gameActive || isImmuneRef.current || isDying) return;
    
    Object.entries(enemyPositions).forEach(([enemyId, enemyPos]) => {
      const dx = spritePos.x - enemyPos.x;
      const dy = spritePos.y - enemyPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 20 && !isImmuneRef.current) {
        isImmuneRef.current = true;
        setHealth(prev => {
          const newHealth = Math.max(0, prev - 50);
          if (newHealth <= 0 && !isDying) {
            playDeathAnimation();
          }
          return newHealth;
        });
        
        setTimeout(() => {
          isImmuneRef.current = false;
        }, 1000);
      }
    });
  }, [enemyPositions, spritePos, gameActive, isDying]);

  // Handle Game Over button clicks separately
  const handleGameOverClick = (e) => {
    e.stopPropagation(); // Prevent the click from reaching elements beneath
  };

  return (
    <div className="sprite-container">
      {/* UI Elements */}
      <div className="game-ui mt-5">
        <div className="health-bar">
          <div className="health-bar-inner" style={{ width: `${health}%` }} />
        </div>
        <div className="score">Score: {score}</div>
      </div>

      {enemies.map(enemy => (
        <PixelEnemy 
          key={enemy.id}
          id={enemy.id}
          playerPos={{
            x: spritePos.x,
            y: spritePos.y + jumpOffset,
            isAttacking: animation.type === 'attack'
          }}
          reportPosition={reportEnemyPosition}
          onDefeated={handleEnemyDefeated}
        />
      ))}
      
      {/* Sprite with frame-based animation */}
      <div
        ref={spriteRef}
        className={`sprite ${animation.type}`}
        data-frame={animation.frame}
        style={{
          transform: `translate(${spritePos.x - 15}px, ${spritePos.y - 30 + jumpOffset}px)`,
          willChange: 'transform',
        }}
      />
      
      {/* Particle Trail */}
      {particles.map((p, i) => (
        <div
          key={i}
          className="particle"
          style={{
            transform: `translate(${p.x - 2}px, ${p.y - 2}px)`,
            opacity: p.life,
            willChange: 'transform, opacity',
          }}
        />
      ))}

      {/* Game Over message */}
      {!gameActive && (
        <div 
          className="game-over"
          onClick={handleGameOverClick}
        >
          <h2>Game Over!</h2>
          <p>Final Score: {score}</p>
          <button onClick={handleRestart}>
            Restart
          </button>
        </div>
      )}

    </div>
  );
};

export default PixelSprite;

---

File: src\Contact.js

import React, { useState } from 'react';
import emailjs from '@emailjs/browser';
import picture from './pictures/porfolio_photos/atSymbol.png';

const ContactPage = () => {
  const [formData, setFormData] = useState({
    from_name: '',
    to_name: 'Ty',
    message: ''
  });
  
  const [status, setStatus] = useState({
    submitting: false,
    submitted: false,
    error: null
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prevState => ({
      ...prevState,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setStatus({ submitting: true, submitted: false, error: null });

    const templateParams = {
      from_name: formData.from_name,
      to_name: formData.to_name,
      message: formData.message
    };

    try {
      await emailjs.send(
        'service_gpbeg2o',
        'template_p5fuu5u',
        templateParams,
        'LXR5pEwAxnbEtCvOP'
      );

      setStatus({
        submitting: false,
        submitted: true,
        error: null
      });

      // Clear form
      setFormData({
        from_name: '',
        to_name: 'Ty',
        message: ''
      });

    } catch (error) {
        debugger;
      console.error('EmailJS Error:', error);
      setStatus({
        submitting: false,
        submitted: false,
        error: 'Failed to send message. Please try again.'
      });
    }
  };

  return ( 
    <div className="container mt-5" style={{width: "100vw", minHeight: "100vh", overflow: "auto"}}>
      <div className='mt-5 p-3 bg-tertiary shadow'> 
        <div className='bg-secondary m-3 p-5 shadow'>
          <h1 className="text-accent mb-4">Contact Me</h1>
          
          {/* Contact Info */}
          <div className="mb-5">
            <div className="mt-5">Email: linxtree<img src={picture} style={{height: "13px"}}/>gmail.com</div>
            <div className="mt-3">LinkedIn: <a href="https://www.linkedin.com/in/ty-crenshaw-641941108/" 
               className="text-accent text-decoration-none">
              Ty Crenshaw
            </a></div>
          </div>

          {/* Contact Form */}
          <div className="bg-tertiary p-4 rounded shadow-sm">
            <h4 className="text-accent mb-4">Send Me a Message</h4>
            
            <form onSubmit={handleSubmit}>
              <div className="mb-3">
                <label htmlFor="from_name" className="form-label">Your Name</label>
                <input
                  type="text"
                  className="form-control"
                  id="from_name"
                  name="from_name"
                  value={formData.from_name}
                  onChange={handleChange}
                  required
                />
              </div>

              <div className="mb-3">
                <label htmlFor="message" className="form-label">Message</label>
                <textarea
                  className="form-control"
                  id="message"
                  name="message"
                  rows="5"
                  value={formData.message}
                  onChange={handleChange}
                  required
                />
              </div>

              {status.error && (
                <div className="alert alert-danger" role="alert">
                  {status.error}
                </div>
              )}

              {status.submitted && (
                <div className="alert alert-success" role="alert">
                  Message sent successfully!
                </div>
              )}

              <button 
                type="submit" 
                className="btn btn-primary"
                disabled={status.submitting}
              >
                {status.submitting ? 'Sending...' : 'Send Message'}
              </button>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ContactPage;

---

File: src\emails\index.js

import * as React from 'react';
import { Html } from '@react-email/html';
import { Button } from '@react-email/button';

export function Email(props) {
  const { url } = props;

  return (
    <Html lang="en">
      <Button href={url}>Click me</Button>
    </Html>
  );
}

---

File: src\ForFunProjects.js

import React from 'react';
import PixelSprite from './components/PixelSprite';

const ForFunProjects = () => {
  return (
    <div className="container mt-5" style={{ width: "100%", minHeight: "100%", overflow: "hidden" }}>
      <h1 className="text-accent mb-4">For Fun Projects</h1>
      <div className="p-3 bg-tertiary shadow">
        <div className="bg-secondary m-3 p-5 shadow">
          <h3 className="text-accent mb-4">Interactive Pixelated Adventure Sprite</h3>
          <p className="text-secondary mb-4">
            Move your mouse to guide a pixel art character around the screen! Press space to make it jump, left click to attack, and watch it leave a trail of pixel dust.
          </p>
          <div className="sprite-wrapper" style={{ position: "relative", height: "0", overflow: "visible" }}>
            <PixelSprite />
          </div>
        </div>
      </div>
    </div>
  );
};

export default ForFunProjects;

---

File: src\game\abilities\abilityDefinitions.js



---

File: src\game\abilities\AbilityManager.js

// Ability casting and management system
import { ProjectileFactory } from '../entities/Projectile.js';
import { ParticleEffects } from '../entities/Particle.js';
import { COLORS, KEY_BINDINGS } from '../constants/gameConstants.js';

export class AbilityManager {
  constructor(abilities, setAbilities) {
    this.abilities = abilities;
    this.setAbilities = setAbilities;
    
    // Ability queue for combo system
    this.abilityQueue = [];
    this.comboWindow = 500; // milliseconds
    
    // Global cooldown
    this.globalCooldown = 0;
    this.globalCooldownMax = 200; // milliseconds
    
    // Ability callbacks
    this.callbacks = {
      onCast: null,
      onCooldownStart: null,
      onCooldownEnd: null,
      onManaInsufficient: null
    };
    
    // Ability upgrade tracking
    this.upgradeHistory = new Map();
  }

  // Register callbacks
  onCast(callback) {
    this.callbacks.onCast = callback;
  }

  onCooldownStart(callback) {
    this.callbacks.onCooldownStart = callback;
  }

  onCooldownEnd(callback) {
    this.callbacks.onCooldownEnd = callback;
  }

  onManaInsufficient(callback) {
    this.callbacks.onManaInsufficient = callback;
  }

  // Update ability cooldowns and durations
  update(deltaTime) {
    // Update global cooldown
    if (this.globalCooldown > 0) {
      this.globalCooldown = Math.max(0, this.globalCooldown - deltaTime);
    }
    
    // Update each ability
    let hasChanges = false;
    
    Object.keys(this.abilities).forEach(abilityName => {
      const ability = this.abilities[abilityName];
      
      // Update cooldown
      if (ability.cooldown > 0) {
        const wasOnCooldown = ability.cooldown > 0;
        ability.cooldown = Math.max(0, ability.cooldown - deltaTime);
        
        if (wasOnCooldown && ability.cooldown === 0) {
          // Cooldown just ended
          if (this.callbacks.onCooldownEnd) {
            this.callbacks.onCooldownEnd(abilityName);
          }
          hasChanges = true;
        }
      }
      
      // Update duration (for buff abilities)
      if (ability.duration !== undefined && ability.duration > 0) {
        ability.duration = Math.max(0, ability.duration - deltaTime);
        hasChanges = true;
      }
    });
    
    // Update ability combo queue
    this.updateComboQueue(deltaTime);
    
    return hasChanges;
  }

  // Update combo queue
  updateComboQueue(deltaTime) {
    this.abilityQueue = this.abilityQueue.filter(entry => {
      entry.time += deltaTime;
      return entry.time < this.comboWindow;
    });
  }

  // Check if ability can be cast
  canCast(abilityName, player) {
    const ability = this.abilities[abilityName];
    if (!ability) return false;
    
    // Check if unlocked (for abilities that need to be purchased)
    if (ability.unlocked === false) {
      return false;
    }
    
    // Check cooldown
    if (ability.cooldown > 0 || this.globalCooldown > 0) {
      return false;
    }
    
    // Check mana
    if (player.mana < ability.manaCost) {
      if (this.callbacks.onManaInsufficient) {
        this.callbacks.onManaInsufficient(abilityName, ability.manaCost, player.mana);
      }
      return false;
    }
    
    // Check if player is alive
    if (!player.isAlive()) {
      return false;
    }
    
    return true;
  }

  // Cast an ability
  cast(abilityName, player, target, gameState) {
    if (!this.canCast(abilityName, player)) {
      return null;
    }
    
    const ability = this.abilities[abilityName];
    let result = null;
    
    // Deduct mana
    player.useMana(ability.manaCost);
    
    // Add to combo queue
    this.abilityQueue.push({ ability: abilityName, time: 0 });
    
    // Cast the specific ability
    switch (abilityName) {
      case 'fireball':
        result = this.castFireball(ability, player, target, gameState);
        break;
        
      case 'heal':
        result = this.castHeal(ability, player, gameState);
        break;
        
      case 'shield':
        result = this.castShield(ability, player, gameState);
        break;
        
      case 'lightning':
        result = this.castLightning(ability, player, gameState);
        break;
        
      case 'meteor':
        result = this.castMeteor(ability, player, target, gameState);
        break;
        
      case 'freeze':
        result = this.castFreeze(ability, player, gameState);
        break;
        
      default:
        break;
    }
    
    // Start cooldown
    this.startCooldown(abilityName);
    
    // Trigger cast callback
    if (this.callbacks.onCast) {
      this.callbacks.onCast(abilityName, result);
    }
    
    return result;
  }

  // Start ability cooldown
  startCooldown(abilityName) {
    const ability = this.abilities[abilityName];
    ability.cooldown = ability.maxCooldown;
    
    // Start global cooldown
    this.globalCooldown = this.globalCooldownMax;
    
    if (this.callbacks.onCooldownStart) {
      this.callbacks.onCooldownStart(abilityName, ability.maxCooldown);
    }
  }

  // Individual ability implementations
  castFireball(ability, player, target, gameState) {
    const projectile = ProjectileFactory.createFireball(
      player.x,
      player.y,
      target.x,
      target.y,
      ability.damage * player.tempEffects.damageMultiplier
    );
    
    return {
      type: 'projectile',
      projectile,
      particles: ParticleEffects.magicCast(player.x, player.y, COLORS.FIREBALL)
    };
  }

  castHeal(ability, player, gameState) {
    const healAmount = player.heal(ability.healAmount);
    
    return {
      type: 'instant',
      effect: 'heal',
      amount: healAmount,
      particles: ParticleEffects.heal(player.x, player.y),
      floatingText: {
        x: player.x,
        y: player.y - 20,
        text: `+${healAmount}`,
        color: COLORS.HEAL_TEXT,
        duration: 1000
      }
    };
  }

  castShield(ability, player, gameState) {
    // Activate shield
    ability.duration = ability.maxDuration;
    
    return {
      type: 'buff',
      effect: 'shield',
      duration: ability.maxDuration,
      particles: ParticleEffects.magicCast(player.x, player.y, COLORS.SHIELD + '1)')
    };
  }

  castLightning(ability, player, gameState) {
    // Find closest enemy
    let closestEnemy = null;
    let closestDistance = Infinity;
    
    gameState.enemies.forEach(enemy => {
      if (!enemy.isAlive) return;
      
      const dx = enemy.x - player.x;
      const dy = enemy.y - player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < ability.range && distance < closestDistance) {
        closestDistance = distance;
        closestEnemy = enemy;
      }
    });
    
    if (!closestEnemy) {
      // Refund mana if no target
      player.restoreMana(ability.manaCost);
      ability.cooldown = 0; // Reset cooldown
      this.setAbilities({...this.abilities});
      return null;
    }
    
    const projectile = ProjectileFactory.createLightning(
      player.x,
      player.y,
      closestEnemy,
      ability.damage * player.tempEffects.damageMultiplier,
      ability.chainCount || 0
    );
    
    return {
      type: 'projectile',
      projectile,
      target: closestEnemy,
      particles: ParticleEffects.magicCast(player.x, player.y, COLORS.LIGHTNING)
    };
  }

  castMeteor(ability, player, target, gameState) {
    // Create delayed meteor impact
    const meteorData = {
      targetX: target.x,
      targetY: target.y,
      damage: ability.damage * player.tempEffects.damageMultiplier,
      delay: ability.warningDuration
    };
    
    return {
      type: 'delayed',
      effect: 'meteor',
      data: meteorData,
      warningParticles: ParticleEffects.magicCast(target.x, target.y, COLORS.METEOR),
      floatingText: {
        x: target.x,
        y: target.y - 50,
        text: 'INCOMING!',
        color: COLORS.METEOR,
        duration: 1500
      }
    };
  }

  castFreeze(ability, player, gameState) {
    // Freeze all enemies
    const frozenEnemies = [];
    
    gameState.enemies.forEach(enemy => {
      if (enemy.isAlive) {
        enemy.freeze(ability.duration);
        frozenEnemies.push(enemy);
      }
    });
    
    return {
      type: 'instant',
      effect: 'freeze',
      targets: frozenEnemies,
      particles: ParticleEffects.explosion(player.x, player.y, COLORS.FREEZE, 1.5),
      floatingText: {
        x: player.x,
        y: player.y - 30,
        text: 'TIME FREEZE!',
        color: COLORS.FREEZE,
        duration: 2000
      }
    };
  }

  // Get ability by key binding
  getAbilityByKey(key) {
    switch (key.toLowerCase()) {
      case KEY_BINDINGS.HEAL:
        return 'heal';
      case KEY_BINDINGS.LIGHTNING:
        return 'lightning';
      case KEY_BINDINGS.SHIELD:
        return 'shield';
      default:
        return null;
    }
  }

  // Get cooldown percentage (0-1)
  getCooldownPercent(abilityName) {
    const ability = this.abilities[abilityName];
    if (!ability || ability.cooldown === 0) return 0;
    
    return ability.cooldown / ability.maxCooldown;
  }

  // Check if ability is on cooldown
  isOnCooldown(abilityName) {
    const ability = this.abilities[abilityName];
    return ability && ability.cooldown > 0;
  }

  // Check if ability is active (for buffs)
  isActive(abilityName) {
    const ability = this.abilities[abilityName];
    return ability && ability.duration !== undefined && ability.duration > 0;
  }

  // Get remaining duration for buff abilities
  getRemainingDuration(abilityName) {
    const ability = this.abilities[abilityName];
    if (!ability || ability.duration === undefined) return 0;
    
    return ability.duration;
  }

  // Upgrade an ability
  upgradeAbility(abilityName, upgrades) {
    const ability = this.abilities[abilityName];
    if (!ability) return false;
    
    // Track upgrade history
    if (!this.upgradeHistory.has(abilityName)) {
      this.upgradeHistory.set(abilityName, []);
    }
    
    const history = this.upgradeHistory.get(abilityName);
    
    // Apply upgrades
    Object.entries(upgrades).forEach(([key, value]) => {
      if (key === 'cooldownReduction') {
        ability.maxCooldown = Math.max(100, ability.maxCooldown - value);
      } else if (key === 'level') {
        ability.level = (ability.level || 1) + value;
      } else {
        ability[key] = (ability[key] || 0) + value;
      }
      
      history.push({ key, value, timestamp: Date.now() });
    });
    
    return true;
  }

  // Reset all cooldowns
  resetCooldowns() {
    Object.values(this.abilities).forEach(ability => {
      ability.cooldown = 0;
      if (ability.duration !== undefined) {
        ability.duration = 0;
      }
    });
    
    this.globalCooldown = 0;
  }

  // Get ability stats for UI
  getAbilityStats(abilityName) {
    const ability = this.abilities[abilityName];
    if (!ability) return null;
    
    return {
      name: abilityName,
      level: ability.level || 1,
      damage: ability.damage || 0,
      healAmount: ability.healAmount || 0,
      manaCost: ability.manaCost,
      cooldown: ability.maxCooldown / 1000, // Convert to seconds
      range: ability.range || 0,
      unlocked: ability.unlocked !== false,
      description: this.getAbilityDescription(abilityName)
    };
  }

  // Get ability description
  getAbilityDescription(abilityName) {
    const descriptions = {
      fireball: 'Launch a fiery projectile at target location',
      heal: 'Restore health instantly',
      shield: 'Create a protective barrier that blocks all damage',
      lightning: 'Strike the nearest enemy with lightning',
      meteor: 'Call down a devastating meteor strike',
      freeze: 'Freeze all enemies in place temporarily'
    };
    
    return descriptions[abilityName] || 'Unknown ability';
  }

  // Get combo string
  getComboString() {
    if (this.abilityQueue.length === 0) return '';
    
    return this.abilityQueue
      .map(entry => entry.ability.charAt(0).toUpperCase())
      .join('-');
  }

  // Check for special combos
  checkCombo() {
    const comboString = this.getComboString();
    
    // Define special combos
    const combos = {
      'F-F-L': { name: 'Lightning Storm', bonus: 1.5 },
      'S-H-S': { name: 'Divine Protection', bonus: 2.0 },
      'L-F-M': { name: 'Elemental Fury', bonus: 1.8 }
    };
    
    return combos[comboString] || null;
  }
}

// Singleton instance
let abilityManagerInstance = null;

export function createAbilityManager(abilities, setAbilities) {
  abilityManagerInstance = new AbilityManager(abilities, setAbilities);
  return abilityManagerInstance;
}

export function getAbilityManager() {
  return abilityManagerInstance;
}

export default AbilityManager;

---

File: src\game\components\GameCanvas.js

// src/game/components/GameCanvas.js
import React, { useRef, useEffect, useCallback } from 'react';
import { GAME_CONFIG, COLORS, VISUAL_CONFIG } from '../constants/gameConstants.js';
// We'll need CollisionSystem and entity creation/factories
import { getCollisionSystem } from '../systems/CollisionSystem.js';
import { createEnemy } from '../entities/Enemy.js'; // Example
import { ProjectileFactory } from '../entities/Projectile.js'; // Example
import { useGameInput } from '../hooks/useGameState'; // Import useGameInput
// Particle system if you have one separate
// import { ParticleSystem, ParticleEffects } from '../entities/Particle.js';

// Helper to add floating text (can be moved to a system/util later)
const addFloatingTextToState = (setGameState, x, y, text, color, duration = 1000) => {
  setGameState(prev => ({
    ...prev,
    floatingTexts: [...(prev.floatingTexts || []), {
      x, y, text, color,
      life: duration, maxLife: duration, alpha: 1, id: Date.now() + Math.random()
    }]
  }));
};

// Helper to add particles (can be moved to a system/util later)
const createParticlesInState = (setGameState, x, y, color, count = 8, particleOptions = {}) => {
  setGameState(prev => {
    const newParticles = [];
    for (let i = 0; i < count; i++) {
      newParticles.push({
        x, y,
        vx: (Math.random() - 0.5) * 6, // Basic particle physics
        vy: (Math.random() - 0.5) * 6 - 2,
        color,
        life: 1 + Math.random(), // in seconds
        id: Date.now() + Math.random(),
        ...particleOptions
      });
    }
    return {
      ...prev,
      particles: [...(prev.particles || []), ...newParticles]
    };
  });
};


function GameCanvas({
  gameState,
  setGameState,
  abilities, // For rendering shield, etc. and ability ranges
  playerRef,
  inputRef,
  mouseRef,
  gameLoopInstance,      // Passed from UltimatePixelGame
  updateAbilitiesSystem, // Passed from UltimatePixelGame
  castAbilitySystem,     // Passed from UltimatePixelGame
  onGameOver
}) {
  const canvasRef = useRef(null);
  const contextRef = useRef(null);
  const collisionSystemRef = useRef(null);

  useGameInput(inputRef, mouseRef, canvasRef);

  // Initialize canvas and context
  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = GAME_CONFIG.CANVAS_WIDTH;
      canvas.height = GAME_CONFIG.CANVAS_HEIGHT;
      contextRef.current = canvas.getContext('2d');
      if (contextRef.current) {
        contextRef.current.imageSmoothingEnabled = false; // For pixel art
      }
    }
    if (!collisionSystemRef.current) {
        collisionSystemRef.current = getCollisionSystem();
    }
  }, []);

  // Main Game Update Logic
  const updateGame = useCallback((deltaTime) => {
    if (!gameState.gameActive || gameState.isPaused || !playerRef.current) return;

    playerRef.current.update(inputRef.current, deltaTime);

    if (updateAbilitiesSystem) {
      updateAbilitiesSystem(deltaTime);
    }

    setGameState(prev => {
      const newState = { ...prev };
      newState.gameTime += deltaTime;

      // Update enemies
      newState.enemies = (newState.enemies || []).map(enemy => {
        if(enemy.update) enemy.update(deltaTime, playerRef.current, newState.enemies);
        return enemy;
      }); // Death filtering happens after collisions

      // Update projectiles
      newState.projectiles = (newState.projectiles || []).map(projectile => {
        if(projectile.update) projectile.update(deltaTime);
        return projectile;
      }).filter(projectile => projectile.isActive); // Filter inactive ones before collision

      // Update powerups (they might move or expire)
      newState.powerups = (newState.powerups || []).map(powerup => {
        if(powerup.update) powerup.update(deltaTime, playerRef.current); // Powerups might be attracted to player
        return powerup;
      }).filter(powerup => powerup.isActive);

      // Update particles...
      newState.particles = (newState.particles || []).filter(p => {
        if (p.life === undefined) p.life = 1; // Default life if missing
        p.life -= deltaTime / 1000;
        p.x += p.vx || 0;
        p.y += p.vy || 0;
        if (p.vy !== undefined) p.vy += (p.gravity !== undefined ? p.gravity : VISUAL_CONFIG.PARTICLE_GRAVITY);
        if (p.vx !== undefined) p.vx *= (p.friction !== undefined ? p.friction : VISUAL_CONFIG.PARTICLE_AIR_RESISTANCE);
        return p.life > 0;
      });


      // Update floating texts...
      newState.floatingTexts = (newState.floatingTexts || []).filter(text => {
          text.life -= deltaTime;
          text.y -= VISUAL_CONFIG.FLOATING_TEXT_RISE_SPEED;
          text.alpha = text.life / text.maxLife;
          return text.life > 0;
      });

      // Update explosions and check their collisions
      const activeExplosions = [];
      (newState.explosions || []).forEach(explosion => {
        explosion.life -= deltaTime;
        if (explosion.life > 0) {
          activeExplosions.push(explosion);
          // Explosion damage is handled by CollisionSystem callback now
        }
      });
      newState.explosions = activeExplosions;

      // Check Collisions
      if (collisionSystemRef.current && playerRef.current) {
        // `abilities` is needed for shield check
        collisionSystemRef.current.checkCollisions(newState, playerRef.current, abilities);
      }

      // Filter dead enemies AFTER collisions have been processed
      newState.enemies = newState.enemies.filter(enemy => enemy.isAlive);


      // Wave System... (simplified, needs to be robust)
      newState.waveTimer += deltaTime;
      if ((newState.enemies.length === 0 && newState.waveTimer > GAME_CONFIG.WAVE_TIMER_MIN) || newState.waveTimer > GAME_CONFIG.WAVE_TIMER_DURATION) {
        newState.wave += 1;
        newState.waveTimer = 0;
        addFloatingTextToState(setGameState, 400, 100, `Wave ${newState.wave}!`, COLORS.EXPERIENCE_TEXT, 2000);
        const numEnemiesToSpawn = Math.min(GAME_CONFIG.INITIAL_ENEMY_COUNT + Math.floor(newState.wave / 2), 12);
        for(let i = 0; i < numEnemiesToSpawn; i++) {
            // TODO: Add staggered spawning if desired using gameLoopInstance.addTimer
            const newEnemy = createEnemy(newState.wave);
            if(newEnemy) newState.enemies.push(newEnemy);
        }
      }
      
      // Update combo timer
      if (newState.combo > 0) {
        newState.comboTimer -= deltaTime;
        if (newState.comboTimer <= 0) {
          newState.combo = 0;
        }
      }


      // Sync player state from playerRef.current object into React's gameState.player
      if (playerRef.current) {
           newState.player = playerRef.current.getState(); // Get fresh state from player object
           if (newState.player.health <= 0 && newState.gameActive) { // Check for game over
               console.log("Player health zero, game over triggered from GameCanvas update");
               newState.gameActive = false;
               if (onGameOver) onGameOver();
           }
       }
      return newState;
    });

  }, [gameState.gameActive, gameState.isPaused, playerRef, inputRef, updateAbilitiesSystem, setGameState, onGameOver, abilities]); // Added `abilities` to deps

  // Main Game Render Logic
  const renderGame = useCallback(() => {
    const ctx = contextRef.current;
    if (!ctx || !playerRef.current) return;

    ctx.clearRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);

    // Draw Background
    const gradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 500);
    gradient.addColorStop(0, COLORS.BG_GRADIENT_CENTER);
    gradient.addColorStop(1, COLORS.BG_GRADIENT_EDGE);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
    // ... (draw grid if you have one) ...

    // Draw Particles
    (gameState.particles || []).forEach(particle => {
      ctx.fillStyle = particle.color;
      ctx.globalAlpha = Math.max(0, particle.life / (particle.maxLife || 1)); // Assuming life is in seconds and maxLife too
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;


    // Draw Enemies
    (gameState.enemies || []).forEach(enemy => {
      if (!enemy.isAlive) return;
      const enemyData = enemy.getVisuals ? enemy.getVisuals() : { x: enemy.x, y: enemy.y, size: enemy.size, color: enemy.color }; // Adapt if Enemy class has getVisuals
      ctx.fillStyle = enemy.lastDamageTime > 0 ? COLORS.WHITE : enemyData.color;
      ctx.fillRect(enemyData.x - enemyData.size / 2, enemyData.y - enemyData.size / 2, enemyData.size, enemyData.size);
      // ... (draw enemy health bars) ...
    });

    // Draw Projectiles
     (gameState.projectiles || []).forEach(projectile => {
        if (!projectile.isActive) return;
        const visual = projectile.getVisualProperties ? projectile.getVisualProperties() : { x: projectile.x, y: projectile.y, size: projectile.size, color: projectile.color };
        ctx.fillStyle = visual.color;
        ctx.beginPath();
        ctx.arc(visual.x, visual.y, visual.size, 0, Math.PI * 2);
        ctx.fill();
    });


    // Draw Player
    ctx.fillStyle = COLORS.PLAYER;
    ctx.fillRect(
      playerRef.current.x - GAME_CONFIG.PLAYER_SIZE / 2,
      playerRef.current.y - GAME_CONFIG.PLAYER_SIZE / 2,
      GAME_CONFIG.PLAYER_SIZE, GAME_CONFIG.PLAYER_SIZE
    );
    // Draw shield if active
    if (abilities.shield && abilities.shield.duration > 0) {
        const shieldAlpha = Math.min(1, abilities.shield.duration / 1000);
        ctx.strokeStyle = `rgba(68, 255, 255, ${shieldAlpha})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(playerRef.current.x, playerRef.current.y, GAME_CONFIG.PLAYER_SIZE + 5, 0, Math.PI * 2);
        ctx.stroke();
    }


    // Draw Floating Texts
    (gameState.floatingTexts || []).forEach(text => {
      ctx.font = 'bold 16px Arial';
      ctx.fillStyle = text.color;
      ctx.globalAlpha = text.alpha;
      ctx.textAlign = 'center';
      ctx.fillText(text.text, text.x, text.y);
    });
    ctx.globalAlpha = 1;

    // Draw Crosshair (if mouseRef is available)
    if (mouseRef && mouseRef.current.x && abilities.fireball) {
        const range = abilities.fireball.range || 200;
        const dx = mouseRef.current.x - playerRef.current.x;
        const dy = mouseRef.current.y - playerRef.current.y;
        const distance = Math.sqrt(dx*dx + dy*dy);

        ctx.strokeStyle = distance <= range ? COLORS.HEAL_TEXT : COLORS.DAMAGE_TEXT;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(mouseRef.current.x - 10, mouseRef.current.y);
        ctx.lineTo(mouseRef.current.x + 10, mouseRef.current.y);
        ctx.moveTo(mouseRef.current.x, mouseRef.current.y - 10);
        ctx.lineTo(mouseRef.current.x, mouseRef.current.y + 10);
        ctx.stroke();
    }


  }, [gameState, abilities, playerRef, mouseRef]); // Add all state/props read during render

  // Setup and manage the game loop
  useEffect(() => {
    if (gameLoopInstance && contextRef.current && playerRef.current) {
      console.log("GameCanvas: Initializing and starting game loop.");
      // The `updateGame` function is the `updateCallback` for the loop
      // The `renderGame` function is the `renderCallback` for the loop
      gameLoopInstance.init(updateGame, renderGame);
      if (!gameLoopInstance.isRunning && gameState.gameActive) {
        gameLoopInstance.start();
      } else if (gameLoopInstance.isRunning && !gameState.gameActive) {
        gameLoopInstance.stop();
      } else if (gameLoopInstance.isRunning && gameState.isPaused && !gameLoopInstance.isPaused) {
        gameLoopInstance.pause();
      } else if (gameLoopInstance.isRunning && !gameState.isPaused && gameLoopInstance.isPaused) {
        gameLoopInstance.resume();
      }
    }

    // Cleanup function for when the component unmounts or dependencies change
    // return () => {
    //   if (gameLoopInstance && gameLoopInstance.isRunning) {
    //     console.log("GameCanvas: Stopping game loop on unmount/deps change.");
    //     gameLoopInstance.stop();
    //   }
    // };
    // The gameLoopInstance lifecycle is now primarily managed by useGameState for restart/full stop.
    // GameCanvas just tells it to pause/resume based on gameState.
  }, [gameLoopInstance, updateGame, renderGame, gameState.gameActive, gameState.isPaused, playerRef]);

  const handlePlayerEnemyCollision = useCallback((collisionData) => {
    const { player, enemy, hasShield } = collisionData; // player is playerRef.current

    if (!enemy.isAlive || !player.isAlive()) return;

    if (hasShield) {
      addFloatingTextToState(setGameState, player.x, player.y - 20, 'BLOCKED!', COLORS.BLOCKED_TEXT, 800);
      createParticlesInState(setGameState, player.x, player.y, COLORS.SHIELD, 6);
      // Knockback enemy (Enemy class needs a knockback method)
      if (enemy.knockback) enemy.knockback(player.x, player.y, GAME_CONFIG.KNOCKBACK_FORCE_ENEMY);
    } else {
      const damageTaken = player.takeDamage(enemy.damage, { x: enemy.x, y: enemy.y }); // Player takes damage
      addFloatingTextToState(setGameState, player.x, player.y - 20, `-${damageTaken}`, COLORS.DAMAGE_TEXT, 1000);
      createParticlesInState(setGameState, player.x, player.y, COLORS.DAMAGE_TEXT, 8);

      // Player knockback is handled inside player.takeDamage
      // No need to call setGameState immediately for player health,
      // as playerRef.current is updated, and sync will happen at end of updateGame.
    }
  }, [setGameState]); // playerRef is stable, GAME_CONFIG and COLORS are constants

  const handleProjectileEnemyCollision = useCallback((collisionData) => {
    const { projectile, enemy } = collisionData;

    if (!enemy.isAlive) {
      return;
    }

    // Determine projectile damage (consider player buffs, crits)
    // This logic might be better placed in AbilityManager or Player class if damage is complex
    let finalDamage = projectile.damage;
    let isCrit = false;
    if (playerRef.current) {
        const effectiveDamage = playerRef.current.getEffectiveDamage(); // Assumes getEffectiveDamage considers projectile's base
        // For simplicity now, let's assume projectile.damage is already buffed.
        // If not, you'd do: finalDamage = projectile.damage * playerRef.current.tempEffects.damageMultiplier;
        // And then apply crit:
        if (Math.random() < playerRef.current.critChance) {
            finalDamage = Math.floor(finalDamage * playerRef.current.critMultiplier);
            isCrit = true;
        }
    }
    finalDamage = Math.floor(finalDamage);


    const damageDealt = enemy.takeDamage(finalDamage); // Enemy takes damage

    if (isCrit) {
      addFloatingTextToState(setGameState, enemy.x, enemy.y - 30, `CRIT! -${finalDamage}`, COLORS.CRITICAL_TEXT, 1000);
      createParticlesInState(setGameState, enemy.x, enemy.y, COLORS.CRITICAL_TEXT, 8);
    } else {
      addFloatingTextToState(setGameState, enemy.x, enemy.y - 20, `-${finalDamage}`, COLORS.WHITE, 800);
    }
    createParticlesInState(setGameState, enemy.x, enemy.y, projectile.color, 6);

    // Projectile is marked !isActive by its own checkHit or update logic
    // Enemy death handling will be done in the main update loop when filtering enemies.
    // Or, if enemy dies here, update score/xp immediately:
    if (!enemy.isAlive) {
        setGameState(prev => {
            const loot = enemy.getLoot ? enemy.getLoot() : { points: enemy.points || 50, experience: (enemy.points || 50)/10 , coins: (enemy.points || 50)/20 };
            const scoreToAdd = Math.floor(loot.points * (1 + (prev.combo || 0) * 0.1));
            if(playerRef.current) {
                playerRef.current.addExperience(loot.experience);
                playerRef.current.addCoins(loot.coins);
            }
            return {
                ...prev,
                score: prev.score + scoreToAdd,
                enemiesKilled: prev.enemiesKilled + 1,
                combo: (prev.combo || 0) + 1,
                comboTimer: GAME_CONFIG.COMBO_TIMER_DURATION,
                // enemies array will be filtered later
            };
        });
        //we dont have loot yet this broke the page
        // addFloatingTextToState(setGameState, enemy.x, enemy.y, `+${Math.floor(loot.points)}`, COLORS.HEAL_TEXT, 1000);
    }


    // Handle meteor explosion
    if (projectile.type === 'meteor' && projectile.explosionRadius) {
      // This logic should trigger an explosion entity or directly damage other enemies
      // For now, let's assume CollisionSystem handles explosion damage separately
      // Or, you'd create an explosion effect here that CollisionSystem then processes
      setGameState(prev => ({
        ...prev,
        explosions: [...(prev.explosions || []), {
            x: projectile.x, y: projectile.y, radius: projectile.explosionRadius,
            damage: projectile.damage * 0.7, // Area damage might be less
            life: 500, maxLife: 500, id: Date.now()
        }]
      }));
    }

  }, [setGameState, playerRef]); // playerRef dependency

  const handlePlayerPowerupCollision = useCallback((collisionData) => {
    const { powerup } = collisionData; // player is playerRef.current

    if (!powerup.isActive || !playerRef.current || !playerRef.current.isAlive()) return;

    const effectResult = powerup.applyEffect(playerRef.current); // Powerup applies its effect
    addFloatingTextToState(setGameState, playerRef.current.x, playerRef.current.y - 20, effectResult.message, powerup.color, 1000);
    createParticlesInState(setGameState, powerup.x, powerup.y, powerup.color, 8);

    // Mark powerup for removal
    setGameState(prev => ({
      ...prev,
      powerups: prev.powerups.filter(p => p.id !== powerup.id)
    }));
  }, [setGameState, playerRef]);

  const handleExplosionEnemyCollision = useCallback((collisionData) => {
    const { enemy, explosion, damagePercent } = collisionData;
    if (!enemy.isAlive) return;

    const explosionDamage = Math.floor(explosion.damage * damagePercent);
    enemy.takeDamage(explosionDamage);

    addFloatingTextToState(setGameState, enemy.x, enemy.y - 20, `-${explosionDamage}`, COLORS.METEOR, 800);
    createParticlesInState(setGameState, enemy.x, enemy.y, COLORS.METEOR, 4);

    if (!enemy.isAlive) {
      // Handle enemy death from explosion (similar to projectile kill)
      setGameState(prev => {
            const loot = enemy.getLoot ? enemy.getLoot() : { points: enemy.points || 50, experience: (enemy.points || 50)/10 , coins: (enemy.points || 50)/20 };
            const scoreToAdd = Math.floor(loot.points * (1 + (prev.combo || 0) * 0.1));
             if(playerRef.current) {
                playerRef.current.addExperience(loot.experience);
                playerRef.current.addCoins(loot.coins);
            }
            return {
                ...prev,
                score: prev.score + scoreToAdd,
                enemiesKilled: prev.enemiesKilled + 1,
                combo: (prev.combo || 0) + 1,
                comboTimer: GAME_CONFIG.COMBO_TIMER_DURATION,
            };
        });
    }
  }, [setGameState, playerRef]);

  // Mouse down handler for shooting (example)
  const handleMouseDown = useCallback((event) => {
    if (!gameState.gameActive || gameState.isPaused || !castAbilitySystem || !canvasRef.current) return;

    const rect = canvasRef.current.getBoundingClientRect();
    const targetX = event.clientX - rect.left;
    const targetY = event.clientY - rect.top;

    // Cast fireball towards mouse position
    castAbilitySystem('fireball', { x: targetX, y: targetY });

  }, [gameState.gameActive, gameState.isPaused, castAbilitySystem]);

  // Add mouse listeners to the canvas
  useEffect(() => {
      const currentCanvas = canvasRef.current;
      if (currentCanvas) {
          currentCanvas.addEventListener('mousedown', handleMouseDown);
      }
      return () => {
          if (currentCanvas) {
              currentCanvas.removeEventListener('mousedown', handleMouseDown);
          }
      };
  }, [handleMouseDown]);

  // useEffect to register collision callbacks with the system
  useEffect(() => {
    const cs = collisionSystemRef.current;
    if (cs) {
      cs.onPlayerEnemyCollision(handlePlayerEnemyCollision);
      cs.onProjectileEnemyCollision(handleProjectileEnemyCollision);
      cs.onPlayerPowerupCollision(handlePlayerPowerupCollision);
      cs.onExplosionEnemyCollision(handleExplosionEnemyCollision);
      // cs.onEnemyEnemyCollision(handleEnemyEnemySeparation); // If you implement this
    }
    // No cleanup needed for these, as CollisionSystem is a singleton and callbacks are replaced
  }, [handlePlayerEnemyCollision, handleProjectileEnemyCollision, handlePlayerPowerupCollision, handleExplosionEnemyCollision]);


  return (
    <canvas
      ref={canvasRef}
      className="game-canvas" // Add a class for potential CSS styling
      style={{
        border: '1px solid black', // Basic border
        cursor: 'crosshair'
        // ... other styles if needed
      }}
    />
  );
}

export default GameCanvas;

---

File: src\game\components\GameOverScreen.js

// Game Over screen component
import React, { useEffect, useState } from 'react';
import { getAchievementById } from '../constants/achievements.js';

export function GameOverScreen({ 
  gameState, 
  onRestart, 
  onMainMenu,
  newAchievements = [],
  highScore = 0
}) {
  const [isVisible, setIsVisible] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [showAchievements, setShowAchievements] = useState(false);
  
  // Animate entrance
  useEffect(() => {
    const timer1 = setTimeout(() => setIsVisible(true), 100);
    const timer2 = setTimeout(() => setShowStats(true), 600);
    const timer3 = setTimeout(() => setShowAchievements(true), 1100);
    
    return () => {
      clearTimeout(timer1);
      clearTimeout(timer2);
      clearTimeout(timer3);
    };
  }, []);
  
  // Format time display
  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };
  
  // Calculate score rating
  const getScoreRating = (score) => {
    if (score >= 10000) return { rating: 'LEGENDARY', color: '#ff00ff' };
    if (score >= 5000) return { rating: 'EPIC', color: '#ff4400' };
    if (score >= 2500) return { rating: 'GREAT', color: '#00ff00' };
    if (score >= 1000) return { rating: 'GOOD', color: '#00ccff' };
    return { rating: 'ROOKIE', color: '#ffffff' };
  };
  
  const scoreRating = getScoreRating(gameState.score);
  const isNewHighScore = gameState.score > highScore;

  return (
    <div style={{
      ...styles.overlay,
      opacity: isVisible ? 1 : 0
    }}>
      <div style={{
        ...styles.container,
        transform: isVisible ? 'scale(1)' : 'scale(0.8)'
      }}>
        {/* Header */}
        <div style={styles.header}>
          <h1 style={styles.title}>GAME OVER</h1>
          {isNewHighScore && (
            <div style={styles.newHighScore}>
               NEW HIGH SCORE! 
            </div>
          )}
        </div>
        
        {/* Main Stats */}
        <div style={{
          ...styles.mainStats,
          opacity: showStats ? 1 : 0,
          transform: showStats ? 'translateY(0)' : 'translateY(20px)'
        }}>
          <div style={styles.scoreContainer}>
            <div style={styles.scoreLabel}>Final Score</div>
            <div style={styles.scoreValue}>{gameState.score.toLocaleString()}</div>
            <div style={{
              ...styles.scoreRating,
              color: scoreRating.color
            }}>
              {scoreRating.rating}
            </div>
          </div>
          
          <div style={styles.statsGrid}>
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{gameState.wave}</div>
              <div style={styles.statLabel}>Wave Reached</div>
            </div>
            
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{gameState.player.level}</div>
              <div style={styles.statLabel}>Level Achieved</div>
            </div>
            
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{gameState.enemiesKilled}</div>
              <div style={styles.statLabel}>Enemies Defeated</div>
            </div>
            
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{formatTime(gameState.gameTime)}</div>
              <div style={styles.statLabel}>Time Survived</div>
            </div>
            
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{gameState.player.coins}</div>
              <div style={styles.statLabel}>Coins Collected</div>
            </div>
            
            <div style={styles.statItem}>
              <div style={styles.statIcon}></div>
              <div style={styles.statValue}>{gameState.combo}</div>
              <div style={styles.statLabel}>Max Combo</div>
            </div>
          </div>
        </div>
        
        {/* New Achievements */}
        {newAchievements.length > 0 && (
          <div style={{
            ...styles.achievementsSection,
            opacity: showAchievements ? 1 : 0,
            transform: showAchievements ? 'translateY(0)' : 'translateY(20px)'
          }}>
            <h3 style={styles.achievementsTitle}>New Achievements!</h3>
            <div style={styles.achievementsList}>
              {newAchievements.map(achievementId => {
                const achievement = getAchievementById(achievementId);
                if (!achievement) return null;
                
                return (
                  <div key={achievement.id} style={styles.achievementItem}>
                    <div style={styles.achievementIcon}>{achievement.icon}</div>
                    <div style={styles.achievementInfo}>
                      <div style={styles.achievementName}>{achievement.name}</div>
                      <div style={styles.achievementDesc}>{achievement.description}</div>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        )}
        
        {/* Buttons */}
        <div style={styles.buttons}>
          <button 
            onClick={onRestart}
            style={{
              ...styles.button,
              ...styles.primaryButton
            }}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
              e.target.style.boxShadow = '0 6px 20px rgba(255,107,107,0.4)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
              e.target.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
            }}
          >
             Play Again
          </button>
          
          <button 
            onClick={onMainMenu}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
              e.target.style.boxShadow = '0 6px 20px rgba(255,255,255,0.2)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
              e.target.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
            }}
          >
             Main Menu
          </button>
        </div>
        
        {/* Tips */}
        <div style={styles.tips}>
          <div style={styles.tipText}>
             Tip: Collect powerups to boost your stats and survive longer!
          </div>
        </div>
      </div>
    </div>
  );
}

const styles = {
  overlay: {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: 'rgba(0, 0, 0, 0.9)',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
    transition: 'opacity 0.5s ease'
  },
  
  container: {
    background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
    border: '3px solid #444',
    borderRadius: '20px',
    padding: '40px',
    maxWidth: '600px',
    width: '90%',
    maxHeight: '90vh',
    overflow: 'auto',
    boxShadow: '0 0 40px rgba(0,0,0,0.8), inset 0 0 20px rgba(255,255,255,0.1)',
    transition: 'transform 0.5s ease',
    color: 'white',
    fontFamily: 'Arial, sans-serif'
  },
  
  header: {
    textAlign: 'center',
    marginBottom: '30px'
  },
  
  title: {
    fontSize: '48px',
    fontWeight: 'bold',
    margin: '0 0 10px 0',
    textShadow: '3px 3px 6px rgba(0,0,0,0.7)',
    background: 'linear-gradient(45deg, #ff6b6b, #ff8e8e)',
    WebkitBackgroundClip: 'text',
    WebkitTextFillColor: 'transparent',
    backgroundClip: 'text'
  },
  
  newHighScore: {
    fontSize: '20px',
    color: '#ffd700',
    fontWeight: 'bold',
    animation: 'pulse 1s ease-in-out infinite',
    textShadow: '0 0 10px rgba(255,215,0,0.5)'
  },
  
  mainStats: {
    marginBottom: '30px',
    transition: 'all 0.5s ease 0.3s'
  },
  
  scoreContainer: {
    textAlign: 'center',
    marginBottom: '30px',
    padding: '20px',
    background: 'rgba(0,0,0,0.4)',
    borderRadius: '15px',
    border: '2px solid #333'
  },
  
  scoreLabel: {
    fontSize: '18px',
    color: '#888',
    marginBottom: '10px'
  },
  
  scoreValue: {
    fontSize: '56px',
    fontWeight: 'bold',
    color: '#fff',
    textShadow: '2px 2px 4px rgba(0,0,0,0.7)',
    lineHeight: '1'
  },
  
  scoreRating: {
    fontSize: '24px',
    fontWeight: 'bold',
    marginTop: '10px',
    textShadow: '0 0 10px currentColor'
  },
  
  statsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',
    gap: '20px'
  },
  
  statItem: {
    background: 'rgba(0,0,0,0.4)',
    padding: '20px',
    borderRadius: '12px',
    textAlign: 'center',
    border: '1px solid #333',
    transition: 'transform 0.2s ease',
    cursor: 'default'
  },
  
  statIcon: {
    fontSize: '32px',
    marginBottom: '10px'
  },
  
  statValue: {
    fontSize: '24px',
    fontWeight: 'bold',
    color: '#fff',
    marginBottom: '5px'
  },
  
  statLabel: {
    fontSize: '14px',
    color: '#888'
  },
  
  achievementsSection: {
    marginBottom: '30px',
    transition: 'all 0.5s ease 0.6s'
  },
  
  achievementsTitle: {
    fontSize: '24px',
    fontWeight: 'bold',
    marginBottom: '15px',
    textAlign: 'center',
    color: '#ffd700'
  },
  
  achievementsList: {
    display: 'flex',
    flexDirection: 'column',
    gap: '10px'
  },
  
  achievementItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '15px',
    background: 'rgba(255,215,0,0.1)',
    padding: '15px',
    borderRadius: '10px',
    border: '1px solid #ffd700'
  },
  
  achievementIcon: {
    fontSize: '32px'
  },
  
  achievementInfo: {
    flex: 1
  },
  
  achievementName: {
    fontSize: '16px',
    fontWeight: 'bold',
    color: '#ffd700',
    marginBottom: '4px'
  },
  
  achievementDesc: {
    fontSize: '14px',
    color: '#ccc'
  },
  
  buttons: {
    display: 'flex',
    gap: '20px',
    justifyContent: 'center',
    marginBottom: '20px'
  },
  
  button: {
    padding: '15px 30px',
    fontSize: '18px',
    fontWeight: 'bold',
    background: 'linear-gradient(45deg, #333, #555)',
    color: 'white',
    border: 'none',
    borderRadius: '25px',
    cursor: 'pointer',
    transition: 'all 0.3s ease',
    boxShadow: '0 4px 15px rgba(0,0,0,0.3)',
    outline: 'none'
  },
  
  primaryButton: {
    background: 'linear-gradient(45deg, #ff6b6b, #ff8e8e)'
  },
  
  tips: {
    textAlign: 'center',
    marginTop: '20px'
  },
  
  tipText: {
    fontSize: '14px',
    color: '#888',
    fontStyle: 'italic'
  }
};

// Add keyframe animation for pulse
const styleSheet = document.createElement('style');
styleSheet.textContent = `
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
`;
document.head.appendChild(styleSheet);

export default GameOverScreen;

---

File: src\game\components\GameUI.js

// Game UI component for HUD and interface - FIXED POSITIONING
import React, { useMemo } from 'react';
import { COLORS, KEY_BINDINGS } from '../constants/gameConstants.js';

export function GameUI({ gameState, abilities, playerRef, onPause, onShopToggle }) {
  const player = playerRef?.current;
  
  // Calculate percentages for bars
  const healthPercent = useMemo(() => {
    if (!player) return 0;
    return (player.health / player.maxHealth) * 100;
  }, [player?.health, player?.maxHealth]);
  
  const manaPercent = useMemo(() => {
    if (!player) return 0;
    return (player.mana / player.maxMana) * 100;
  }, [player?.mana, player?.maxMana]);
  
  const experiencePercent = useMemo(() => {
    if (!player) return 0;
    return (player.experience / player.experienceToNext) * 100;
  }, [player?.experience, player?.experienceToNext]);
  
  // Format time display
  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };
  
  // Get ability cooldown display
  const getAbilityCooldown = (ability) => {
    if (!ability || ability.cooldown === 0) return '';
    return Math.ceil(ability.cooldown / 1000).toString();
  };
  
  // Get ability ready state
  const isAbilityReady = (ability) => {
    return ability && ability.cooldown === 0 && player?.mana >= ability.manaCost;
  };

  return (
    <div className="game-ui" style={styles.container}>
      {/* Top Bar - Player Stats */}
      <div style={styles.topBar}>
        <div style={styles.statsPanel}>
          {/* Health Bar */}
          <div style={styles.barContainer}>
            <div style={styles.barLabel}>
              <span style={styles.barIcon}></span>
              <span>Health</span>
              <span style={styles.barValue}>{Math.floor(player?.health || 0)}/{player?.maxHealth || 100}</span>
            </div>
            <div style={styles.barBackground}>
              <div 
                style={{
                  ...styles.healthBar,
                  width: `${healthPercent}%`
                }}
              />
            </div>
          </div>
          
          {/* Mana Bar */}
          <div style={styles.barContainer}>
            <div style={styles.barLabel}>
              <span style={styles.barIcon}></span>
              <span>Mana</span>
              <span style={styles.barValue}>{Math.floor(player?.mana || 0)}/{player?.maxMana || 100}</span>
            </div>
            <div style={styles.barBackground}>
              <div 
                style={{
                  ...styles.manaBar,
                  width: `${manaPercent}%`
                }}
              />
            </div>
          </div>
          
          {/* Experience Bar */}
          <div style={styles.barContainer}>
            <div style={styles.barLabel}>
              <span style={styles.barIcon}></span>
              <span>Level {player?.level || 1}</span>
              <span style={styles.barValue}>{Math.floor(player?.experience || 0)}/{player?.experienceToNext || 100} XP</span>
            </div>
            <div style={styles.barBackground}>
              <div 
                style={{
                  ...styles.experienceBar,
                  width: `${experiencePercent}%`
                }}
              />
            </div>
          </div>
        </div>
        
        {/* Game Stats */}
        <div style={styles.gameStats}>
          <div style={styles.statItem}>
            <span style={styles.statLabel}>Score</span>
            <span style={styles.statValue}>{gameState.score.toLocaleString()}</span>
          </div>
          <div style={styles.statItem}>
            <span style={styles.statLabel}>Wave</span>
            <span style={styles.statValue}>{gameState.wave}</span>
          </div>
          <div style={styles.statItem}>
            <span style={styles.statLabel}>Enemies</span>
            <span style={styles.statValue}>{gameState.enemies.length}</span>
          </div>
          <div style={styles.statItem}>
            <span style={styles.statLabel}>Time</span>
            <span style={styles.statValue}>{formatTime(gameState.gameTime)}</span>
          </div>
        </div>
        
        {/* Resources */}
        <div style={styles.resources}>
          <div style={styles.resourceItem}>
            <span style={styles.resourceIcon}></span>
            <span style={styles.resourceValue}>{player?.coins || 0}</span>
          </div>
          <div style={styles.resourceItem}>
            <span style={styles.resourceIcon}></span>
            <span style={styles.resourceValue}>{gameState.enemiesKilled}</span>
          </div>
          {gameState.combo > 1 && (
            <div style={styles.comboIndicator}>
              <span style={styles.comboText}>{gameState.combo}x COMBO!</span>
            </div>
          )}
        </div>
      </div>
      
      {/* Bottom Bar - Abilities */}
      <div style={styles.bottomBar}>
        <div style={styles.abilitiesContainer}>
          {/* Fireball (Mouse) */}
          <div style={{
            ...styles.abilitySlot,
            opacity: isAbilityReady(abilities.fireball) ? 1 : 0.5
          }}>
            <div style={styles.abilityIcon}></div>
            <div style={styles.abilityName}>Fireball</div>
            <div style={styles.abilityKey}>CLICK</div>
            {abilities.fireball?.cooldown > 0 && (
              <div style={styles.cooldownOverlay}>
                <div style={styles.cooldownText}>{getAbilityCooldown(abilities.fireball)}</div>
              </div>
            )}
            <div style={styles.manaCost}>{abilities.fireball?.manaCost} MP</div>
          </div>
          
          {/* Heal (Space) */}
          <div style={{
            ...styles.abilitySlot,
            opacity: isAbilityReady(abilities.heal) ? 1 : 0.5
          }}>
            <div style={styles.abilityIcon}></div>
            <div style={styles.abilityName}>Heal</div>
            <div style={styles.abilityKey}>SPACE</div>
            {abilities.heal?.cooldown > 0 && (
              <div style={styles.cooldownOverlay}>
                <div style={styles.cooldownText}>{getAbilityCooldown(abilities.heal)}</div>
              </div>
            )}
            <div style={styles.manaCost}>{abilities.heal?.manaCost} MP</div>
          </div>
          
          {/* Lightning (Q) */}
          <div style={{
            ...styles.abilitySlot,
            opacity: isAbilityReady(abilities.lightning) ? 1 : 0.5
          }}>
            <div style={styles.abilityIcon}></div>
            <div style={styles.abilityName}>Lightning</div>
            <div style={styles.abilityKey}>Q</div>
            {abilities.lightning?.cooldown > 0 && (
              <div style={styles.cooldownOverlay}>
                <div style={styles.cooldownText}>{getAbilityCooldown(abilities.lightning)}</div>
              </div>
            )}
            <div style={styles.manaCost}>{abilities.lightning?.manaCost} MP</div>
          </div>
          
          {/* Shield (E) */}
          <div style={{
            ...styles.abilitySlot,
            opacity: isAbilityReady(abilities.shield) ? 1 : 0.5,
            border: abilities.shield?.duration > 0 ? '2px solid #00ffff' : '2px solid #444'
          }}>
            <div style={styles.abilityIcon}></div>
            <div style={styles.abilityName}>Shield</div>
            <div style={styles.abilityKey}>E</div>
            {abilities.shield?.duration > 0 ? (
              <div style={styles.durationOverlay}>
                <div style={styles.durationText}>{Math.ceil(abilities.shield.duration / 1000)}s</div>
              </div>
            ) : abilities.shield?.cooldown > 0 && (
              <div style={styles.cooldownOverlay}>
                <div style={styles.cooldownText}>{getAbilityCooldown(abilities.shield)}</div>
              </div>
            )}
            <div style={styles.manaCost}>{abilities.shield?.manaCost} MP</div>
          </div>
          
          {/* Meteor (if unlocked) */}
          {abilities.meteor?.unlocked && (
            <div style={{
              ...styles.abilitySlot,
              opacity: isAbilityReady(abilities.meteor) ? 1 : 0.5
            }}>
              <div style={styles.abilityIcon}></div>
              <div style={styles.abilityName}>Meteor</div>
              <div style={styles.abilityKey}>R</div>
              {abilities.meteor?.cooldown > 0 && (
                <div style={styles.cooldownOverlay}>
                  <div style={styles.cooldownText}>{getAbilityCooldown(abilities.meteor)}</div>
                </div>
              )}
              <div style={styles.manaCost}>{abilities.meteor?.manaCost} MP</div>
            </div>
          )}
          
          {/* Freeze (if unlocked) */}
          {abilities.freeze?.unlocked && (
            <div style={{
              ...styles.abilitySlot,
              opacity: isAbilityReady(abilities.freeze) ? 1 : 0.5
            }}>
              <div style={styles.abilityIcon}></div>
              <div style={styles.abilityName}>Freeze</div>
              <div style={styles.abilityKey}>F</div>
              {abilities.freeze?.cooldown > 0 && (
                <div style={styles.cooldownOverlay}>
                  <div style={styles.cooldownText}>{getAbilityCooldown(abilities.freeze)}</div>
                </div>
              )}
              <div style={styles.manaCost}>{abilities.freeze?.manaCost} MP</div>
            </div>
          )}
        </div>
        
        {/* Control Buttons */}
        <div style={styles.controlButtons}>
          <button onClick={onShopToggle} style={styles.controlButton}>
             Shop
          </button>
          <button onClick={onPause} style={styles.controlButton}>
             Pause
          </button>
        </div>
      </div>
      
      {/* Active Effects Display */}
      {(player?.tempEffects?.speedDuration > 0 || player?.tempEffects?.damageDuration > 0) && (
        <div style={styles.activeEffects}>
          <div style={styles.effectsTitle}>Active Effects</div>
          {player.tempEffects.speedDuration > 0 && (
            <div style={styles.effectItem}>
              <span style={styles.effectIcon}></span>
              <span>Speed Boost: {Math.ceil(player.tempEffects.speedDuration / 1000)}s</span>
            </div>
          )}
          {player.tempEffects.damageDuration > 0 && (
            <div style={styles.effectItem}>
              <span style={styles.effectIcon}></span>
              <span>Damage Boost: {Math.ceil(player.tempEffects.damageDuration / 1000)}s</span>
            </div>
          )}
        </div>
      )}
      
      {/* Controls Help (toggleable) */}
      <div style={styles.controlsHelp}>
        <div style={styles.helpTitle}>Controls</div>
        <div style={styles.helpGrid}>
          <div>WASD - Move</div>
          <div>Mouse - Aim/Fire</div>
          <div>Space - Heal</div>
          <div>Q - Lightning</div>
          <div>E - Shield</div>
          <div>P - Pause</div>
        </div>
      </div>
    </div>
  );
}

// Updated Styles with proper positioning
const styles = {
  container: {
    position: 'absolute',
    top: '55px', // Added margin to avoid browser UI
    left: 0,
    right: 0,
    bottom: '20px', // Added margin at bottom
    pointerEvents: 'none',
    fontFamily: 'Arial, sans-serif',
    color: 'white',
    userSelect: 'none'
  },
  
  topBar: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    display: 'flex',
    justifyContent: 'space-between',
    padding: '15px 20px', // Reduced padding
    background: 'linear-gradient(to bottom, rgba(0,0,0,0.8), transparent)',
    pointerEvents: 'auto'
  },
  
  statsPanel: {
    display: 'flex',
    flexDirection: 'column',
    gap: '6px', // Reduced gap
    minWidth: '220px' // Slightly smaller
  },
  
  barContainer: {
    display: 'flex',
    flexDirection: 'column',
    gap: '3px'
  },
  
  barLabel: {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    fontSize: '13px' // Slightly smaller
  },
  
  barIcon: {
    fontSize: '14px'
  },
  
  barValue: {
    marginLeft: 'auto',
    fontSize: '11px',
    color: '#ccc'
  },
  
  barBackground: {
    width: '180px', // Smaller bars
    height: '16px', // Thinner bars
    background: 'rgba(0,0,0,0.6)',
    border: '1px solid #333',
    borderRadius: '8px',
    overflow: 'hidden',
    position: 'relative'
  },
  
  healthBar: {
    height: '100%',
    background: 'linear-gradient(90deg, #ff0000, #ff6600)',
    transition: 'width 0.3s ease',
    boxShadow: '0 0 8px rgba(255,0,0,0.5)'
  },
  
  manaBar: {
    height: '100%',
    background: 'linear-gradient(90deg, #0066ff, #00ccff)',
    transition: 'width 0.3s ease',
    boxShadow: '0 0 8px rgba(0,102,255,0.5)'
  },
  
  experienceBar: {
    height: '100%',
    background: 'linear-gradient(90deg, #ffaa00, #ffff00)',
    transition: 'width 0.3s ease',
    boxShadow: '0 0 8px rgba(255,255,0,0.5)'
  },
  
  gameStats: {
    display: 'flex',
    gap: '15px', // Reduced gap
    alignItems: 'center'
  },
  
  statItem: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '3px'
  },
  
  statLabel: {
    fontSize: '11px',
    color: '#aaa',
    textTransform: 'uppercase'
  },
  
  statValue: {
    fontSize: '18px', // Slightly smaller
    fontWeight: 'bold',
    textShadow: '2px 2px 4px rgba(0,0,0,0.5)'
  },
  
  resources: {
    display: 'flex',
    flexDirection: 'column',
    gap: '6px',
    alignItems: 'flex-end'
  },
  
  resourceItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    background: 'rgba(0,0,0,0.6)',
    padding: '3px 10px', // Smaller padding
    borderRadius: '15px',
    border: '1px solid #333'
  },
  
  resourceIcon: {
    fontSize: '16px'
  },
  
  resourceValue: {
    fontSize: '16px',
    fontWeight: 'bold'
  },
  
  comboIndicator: {
    background: 'linear-gradient(45deg, #ff6600, #ffaa00)',
    padding: '6px 12px',
    borderRadius: '15px',
    animation: 'pulse 0.5s ease-in-out infinite'
  },
  
  comboText: {
    fontSize: '16px',
    fontWeight: 'bold',
    textShadow: '2px 2px 4px rgba(0,0,0,0.5)'
  },
  
  bottomBar: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
    padding: '15px 20px', // Reduced padding
    background: 'linear-gradient(to top, rgba(0,0,0,0.8), transparent)',
    pointerEvents: 'auto'
  },
  
  abilitiesContainer: {
    display: 'flex',
    gap: '8px' // Reduced gap
  },
  
  abilitySlot: {
    position: 'relative',
    width: '70px', // Smaller slots
    height: '70px',
    background: 'rgba(0,0,0,0.8)',
    border: '2px solid #444',
    borderRadius: '8px',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'all 0.2s ease',
    cursor: 'pointer'
  },
  
  abilityIcon: {
    fontSize: '26px', // Smaller icons
    marginBottom: '2px'
  },
  
  abilityName: {
    fontSize: '10px',
    fontWeight: 'bold'
  },
  
  abilityKey: {
    fontSize: '9px',
    color: '#aaa',
    position: 'absolute',
    top: '3px',
    right: '3px',
    background: 'rgba(0,0,0,0.8)',
    padding: '1px 3px',
    borderRadius: '3px'
  },
  
  manaCost: {
    fontSize: '9px',
    color: '#00ccff',
    position: 'absolute',
    bottom: '3px',
    left: '3px'
  },
  
  cooldownOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: 'rgba(0,0,0,0.7)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: '6px'
  },
  
  cooldownText: {
    fontSize: '20px',
    fontWeight: 'bold',
    color: '#ff6666'
  },
  
  durationOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: 'rgba(0,255,255,0.2)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: '6px',
    border: '2px solid #00ffff'
  },
  
  durationText: {
    fontSize: '16px',
    fontWeight: 'bold',
    color: '#00ffff',
    textShadow: '0 0 8px rgba(0,255,255,0.8)'
  },
  
  controlButtons: {
    display: 'flex',
    gap: '8px'
  },
  
  controlButton: {
    padding: '8px 16px', // Smaller buttons
    background: 'rgba(0,0,0,0.8)',
    border: '2px solid #444',
    borderRadius: '6px',
    color: 'white',
    fontSize: '12px',
    fontWeight: 'bold',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    pointerEvents: 'auto'
  },
  
  activeEffects: {
    position: 'absolute',
    top: '120px', // Adjusted position
    right: '20px',
    background: 'rgba(0,0,0,0.8)',
    padding: '10px',
    borderRadius: '8px',
    border: '1px solid #444',
    minWidth: '180px'
  },
  
  effectsTitle: {
    fontSize: '12px',
    fontWeight: 'bold',
    marginBottom: '6px',
    textAlign: 'center',
    color: '#ffaa00'
  },
  
  effectItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '6px',
    fontSize: '11px',
    marginBottom: '3px'
  },
  
  effectIcon: {
    fontSize: '14px'
  },
  
  controlsHelp: {
    position: 'absolute',
    bottom: '90px', // Adjusted position
    left: '20px',
    background: 'rgba(0,0,0,0.8)',
    padding: '10px',
    borderRadius: '8px',
    border: '1px solid #444',
    fontSize: '11px',
    opacity: 0.7,
    transition: 'opacity 0.2s ease'
  },
  
  helpTitle: {
    fontSize: '12px',
    fontWeight: 'bold',
    marginBottom: '6px',
    textAlign: 'center'
  },
  
  helpGrid: {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr',
    gap: '3px 10px'
  }
};

export default GameUI;

---

File: src\game\components\PauseScreen.js

// Pause screen component
import React, { useState } from 'react';
import { KEY_BINDINGS } from '../constants/gameConstants.js';

export function PauseScreen({ 
  onResume, 
  onRestart, 
  onMainMenu,
  onSettingsToggle,
  gameState,
  soundEnabled = true,
  onSoundToggle
}) {
  const [showControls, setShowControls] = useState(false);
  const [showStats, setShowStats] = useState(false);
  
  // Format time display
  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <div style={styles.overlay}>
      <div style={styles.container}>
        {/* Header */}
        <div style={styles.header}>
          <h1 style={styles.title}>PAUSED</h1>
          <div style={styles.subtitle}>Press P to Resume</div>
        </div>
        
        {/* Main Menu */}
        <div style={styles.menuSection}>
          <button 
            onClick={onResume}
            style={{
              ...styles.button,
              ...styles.primaryButton
            }}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
              e.target.style.boxShadow = '0 6px 20px rgba(0,255,0,0.4)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
              e.target.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
            }}
          >
             Resume Game
          </button>
          
          <button 
            onClick={onRestart}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
             Restart
          </button>
          
          <button 
            onClick={() => setShowControls(!showControls)}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
             Controls
          </button>
          
          <button 
            onClick={() => setShowStats(!showStats)}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
             Stats
          </button>
          
          <button 
            onClick={onSoundToggle}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
            {soundEnabled ? ' Sound: ON' : ' Sound: OFF'}
          </button>
          
          <button 
            onClick={onMainMenu}
            style={styles.button}
            onMouseEnter={(e) => {
              e.target.style.transform = 'scale(1.05)';
            }}
            onMouseLeave={(e) => {
              e.target.style.transform = 'scale(1)';
            }}
          >
             Main Menu
          </button>
        </div>
        
        {/* Controls Section */}
        {showControls && (
          <div style={styles.infoSection}>
            <h3 style={styles.infoTitle}>Game Controls</h3>
            <div style={styles.controlsGrid}>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>WASD</div>
                <div style={styles.controlDesc}>Move Character</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>Mouse</div>
                <div style={styles.controlDesc}>Aim & Fire</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>Click</div>
                <div style={styles.controlDesc}>Cast Fireball</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>Space</div>
                <div style={styles.controlDesc}>Heal</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>Q</div>
                <div style={styles.controlDesc}>Lightning Strike</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>E</div>
                <div style={styles.controlDesc}>Shield</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>R</div>
                <div style={styles.controlDesc}>Meteor (if unlocked)</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>F</div>
                <div style={styles.controlDesc}>Freeze (if unlocked)</div>
              </div>
              <div style={styles.controlItem}>
                <div style={styles.controlKey}>P</div>
                <div style={styles.controlDesc}>Pause/Resume</div>
              </div>
            </div>
          </div>
        )}
        
        {/* Stats Section */}
        {showStats && gameState && (
          <div style={styles.infoSection}>
            <h3 style={styles.infoTitle}>Current Game Stats</h3>
            <div style={styles.statsGrid}>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Score</div>
                <div style={styles.statValue}>{gameState.score.toLocaleString()}</div>
              </div>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Wave</div>
                <div style={styles.statValue}>{gameState.wave}</div>
              </div>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Level</div>
                <div style={styles.statValue}>{gameState.player.level}</div>
              </div>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Enemies Killed</div>
                <div style={styles.statValue}>{gameState.enemiesKilled}</div>
              </div>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Time Played</div>
                <div style={styles.statValue}>{formatTime(gameState.gameTime)}</div>
              </div>
              <div style={styles.statItem}>
                <div style={styles.statLabel}>Coins</div>
                <div style={styles.statValue}>{gameState.player.coins}</div>
              </div>
            </div>
          </div>
        )}
        
        {/* Tips */}
        <div style={styles.tips}>
          <div style={styles.tipText}>
             Tip: Combine abilities for powerful combos!
          </div>
        </div>
      </div>
    </div>
  );
}

const styles = {
  overlay: {
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    background: 'rgba(0, 0, 0, 0.85)',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
    backdropFilter: 'blur(5px)'
  },
  
  container: {
    background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
    border: '3px solid #444',
    borderRadius: '20px',
    padding: '40px',
    maxWidth: '500px',
    width: '90%',
    maxHeight: '90vh',
    overflow: 'auto',
    boxShadow: '0 0 40px rgba(0,0,0,0.8), inset 0 0 20px rgba(255,255,255,0.1)',
    color: 'white',
    fontFamily: 'Arial, sans-serif'
  },
  
  header: {
    textAlign: 'center',
    marginBottom: '30px'
  },
  
  title: {
    fontSize: '48px',
    fontWeight: 'bold',
    margin: '0 0 10px 0',
    textShadow: '3px 3px 6px rgba(0,0,0,0.7)',
    background: 'linear-gradient(45deg, #00ff00, #00cc00)',
    WebkitBackgroundClip: 'text',
    WebkitTextFillColor: 'transparent',
    backgroundClip: 'text',
    letterSpacing: '3px'
  },
  
  subtitle: {
    fontSize: '16px',
    color: '#888',
    fontStyle: 'italic'
  },
  
  menuSection: {
    display: 'flex',
    flexDirection: 'column',
    gap: '15px',
    marginBottom: '30px'
  },
  
  button: {
    padding: '15px 25px',
    fontSize: '18px',
    fontWeight: 'bold',
    background: 'linear-gradient(45deg, #333, #555)',
    color: 'white',
    border: 'none',
    borderRadius: '25px',
    cursor: 'pointer',
    transition: 'all 0.3s ease',
    boxShadow: '0 4px 15px rgba(0,0,0,0.3)',
    outline: 'none',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: '10px'
  },
  
  primaryButton: {
    background: 'linear-gradient(45deg, #00ff00, #00cc00)',
    fontSize: '20px',
    padding: '18px 30px'
  },
  
  infoSection: {
    background: 'rgba(0,0,0,0.4)',
    padding: '20px',
    borderRadius: '15px',
    marginBottom: '20px',
    border: '1px solid #333'
  },
  
  infoTitle: {
    fontSize: '20px',
    fontWeight: 'bold',
    marginBottom: '15px',
    textAlign: 'center',
    color: '#00ff00'
  },
  
  controlsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '15px'
  },
  
  controlItem: {
    display: 'flex',
    alignItems: 'center',
    gap: '10px',
    padding: '10px',
    background: 'rgba(0,0,0,0.3)',
    borderRadius: '8px'
  },
  
  controlKey: {
    background: 'linear-gradient(45deg, #444, #666)',
    padding: '5px 10px',
    borderRadius: '5px',
    fontWeight: 'bold',
    minWidth: '60px',
    textAlign: 'center',
    boxShadow: '0 2px 5px rgba(0,0,0,0.5)',
    border: '1px solid #777'
  },
  
  controlDesc: {
    fontSize: '14px',
    color: '#ccc'
  },
  
  statsGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(2, 1fr)',
    gap: '15px'
  },
  
  statItem: {
    background: 'rgba(0,0,0,0.3)',
    padding: '15px',
    borderRadius: '10px',
    textAlign: 'center'
  },
  
  statLabel: {
    fontSize: '14px',
    color: '#888',
    marginBottom: '5px'
  },
  
  statValue: {
    fontSize: '20px',
    fontWeight: 'bold',
    color: '#00ff00'
  },
  
  tips: {
    textAlign: 'center',
    marginTop: '20px',
    padding: '15px',
    background: 'rgba(0,255,0,0.1)',
    borderRadius: '10px',
    border: '1px solid rgba(0,255,0,0.3)'
  },
  
  tipText: {
    fontSize: '14px',
    color: '#aaa',
    fontStyle: 'italic'
  }
};

export default PauseScreen;

---

File: src\game\components\Shop.js



---

File: src\game\constants\achievements.js

// Achievement system configuration
// Each achievement has conditions, rewards, and tracking logic

export const ACHIEVEMENT_CATEGORIES = {
    COMBAT: 'combat',
    PROGRESSION: 'progression',
    SKILL: 'skill',
    COLLECTION: 'collection',
    SPECIAL: 'special'
  };
  
  export const achievementList = [
    // Combat achievements
    {
      id: 'first_kill',
      name: 'First Blood',
      description: 'Kill your first enemy',
      category: ACHIEVEMENT_CATEGORIES.COMBAT,
      icon: '',
      condition: (state) => state.enemiesKilled >= 1,
      reward: { coins: 50, experience: 100 },
      hidden: false
    },
    {
      id: 'slayer_10',
      name: 'Slayer',
      description: 'Kill 10 enemies',
      category: ACHIEVEMENT_CATEGORIES.COMBAT,
      icon: '',
      condition: (state) => state.enemiesKilled >= 10,
      reward: { coins: 75, experience: 150 },
      hidden: false
    },
    {
      id: 'slayer_50',
      name: 'Veteran Slayer',
      description: 'Kill 50 enemies',
      category: ACHIEVEMENT_CATEGORIES.COMBAT,
      icon: '',
      condition: (state) => state.enemiesKilled >= 50,
      reward: { coins: 150, experience: 300 },
      hidden: false
    },
    {
      id: 'slayer_100',
      name: 'Master Slayer',
      description: 'Kill 100 enemies',
      category: ACHIEVEMENT_CATEGORIES.COMBAT,
      icon: '',
      condition: (state) => state.enemiesKilled >= 100,
      reward: { coins: 300, experience: 500 },
      hidden: false
    },
    {
      id: 'boss_slayer',
      name: 'Boss Slayer',
      description: 'Defeat your first boss enemy',
      category: ACHIEVEMENT_CATEGORIES.COMBAT,
      icon: '',
      condition: (state, context) => context?.bossKilled === true,
      reward: { coins: 200, experience: 400 },
      hidden: false
    },
  
    // Progression achievements
    {
      id: 'wave_5',
      name: 'Survivor',
      description: 'Reach wave 5',
      category: ACHIEVEMENT_CATEGORIES.PROGRESSION,
      icon: '',
      condition: (state) => state.wave >= 5,
      reward: { coins: 100, experience: 200 },
      hidden: false
    },
    {
      id: 'wave_10',
      name: 'Veteran',
      description: 'Reach wave 10',
      category: ACHIEVEMENT_CATEGORIES.PROGRESSION,
      icon: '',
      condition: (state) => state.wave >= 10,
      reward: { coins: 200, experience: 400 },
      hidden: false
    },
    {
      id: 'wave_20',
      name: 'Elite',
      description: 'Reach wave 20',
      category: ACHIEVEMENT_CATEGORIES.PROGRESSION,
      icon: '',
      condition: (state) => state.wave >= 20,
      reward: { coins: 500, experience: 1000 },
      hidden: false
    },
    {
      id: 'level_5',
      name: 'Experienced',
      description: 'Reach level 5',
      category: ACHIEVEMENT_CATEGORIES.PROGRESSION,
      icon: '',
      condition: (state) => state.player.level >= 5,
      reward: { coins: 100, experience: 0 }, // No XP reward for level achievement
      hidden: false
    },
    {
      id: 'level_10',
      name: 'Veteran Mage',
      description: 'Reach level 10',
      category: ACHIEVEMENT_CATEGORIES.PROGRESSION,
      icon: '',
      condition: (state) => state.player.level >= 10,
      reward: { coins: 250, experience: 0 },
      hidden: false
    },
  
    // Skill achievements
    {
      id: 'combo_10',
      name: 'Combo Master',
      description: 'Get a 10x combo',
      category: ACHIEVEMENT_CATEGORIES.SKILL,
      icon: '',
      condition: (state) => state.combo >= 10,
      reward: { coins: 150, experience: 300 },
      hidden: false
    },
    {
      id: 'combo_20',
      name: 'Combo Legend',
      description: 'Get a 20x combo',
      category: ACHIEVEMENT_CATEGORIES.SKILL,
      icon: '',
      condition: (state) => state.combo >= 20,
      reward: { coins: 300, experience: 600 },
      hidden: true // Hidden until combo_10 is achieved
    },
    {
      id: 'perfectionist',
      name: 'Untouchable',
      description: 'Complete a wave without taking damage',
      category: ACHIEVEMENT_CATEGORIES.SKILL,
      icon: '',
      condition: (state, context) => context?.wavePerfect === true,
      reward: { coins: 200, experience: 400 },
      hidden: false
    },
    {
      id: 'speed_demon',
      name: 'Speed Demon',
      description: 'Kill 20 enemies in 30 seconds',
      category: ACHIEVEMENT_CATEGORIES.SKILL,
      icon: '',
      condition: (state, context) => context?.speedKills >= 20,
      reward: { coins: 250, experience: 500 },
      hidden: false
    },
    {
      id: 'survivor_pro',
      name: 'Survivor Pro',
      description: 'Survive for 10 minutes',
      category: ACHIEVEMENT_CATEGORIES.SKILL,
      icon: '',
      condition: (state) => state.gameTime >= 600000, // 10 minutes in ms
      reward: { coins: 300, experience: 600 },
      hidden: false
    },
  
    // Collection achievements
    {
      id: 'rich',
      name: 'Wealthy Mage',
      description: 'Collect 500 coins',
      category: ACHIEVEMENT_CATEGORIES.COLLECTION,
      icon: '',
      condition: (state) => state.player.coins >= 500,
      reward: { coins: 100, experience: 200 },
      hidden: false
    },
    {
      id: 'rich_1000',
      name: 'Midas Touch',
      description: 'Collect 1000 coins',
      category: ACHIEVEMENT_CATEGORIES.COLLECTION,
      icon: '',
      condition: (state) => state.player.coins >= 1000,
      reward: { coins: 200, experience: 400 },
      hidden: true
    },
    {
      id: 'shopaholic',
      name: 'Shopaholic',
      description: 'Purchase 5 items from the shop',
      category: ACHIEVEMENT_CATEGORIES.COLLECTION,
      icon: '',
      condition: (state, context) => context?.purchasedItems?.length >= 5,
      reward: { coins: 150, experience: 300 },
      hidden: false
    },
  
    // Special achievements
    {
      id: 'full_health_level',
      name: 'Healthy Living',
      description: 'Level up while at full health',
      category: ACHIEVEMENT_CATEGORIES.SPECIAL,
      icon: '',
      condition: (state, context) => context?.levelUpAtFullHealth === true,
      reward: { coins: 100, experience: 200 },
      hidden: true
    },
    {
      id: 'close_call',
      name: 'Close Call',
      description: 'Survive with less than 10 HP',
      category: ACHIEVEMENT_CATEGORIES.SPECIAL,
      icon: '',
      condition: (state) => state.player.health < 10 && state.player.health > 0,
      reward: { coins: 150, experience: 300 },
      hidden: true
    },
    {
      id: 'pacifist',
      name: 'Pacifist',
      description: 'Survive a wave without killing any enemies',
      category: ACHIEVEMENT_CATEGORIES.SPECIAL,
      icon: '',
      condition: (state, context) => context?.pacifistWave === true,
      reward: { coins: 200, experience: 400 },
      hidden: true
    }
  ];
  
  // Track achievement progress
  export const achievementProgress = {
    speedKillsTimer: 0,
    speedKillsCount: 0,
    waveStartHealth: 100,
    waveEnemiesKilled: 0,
    waveDamageTaken: 0,
    purchasedItems: [],
    totalCoinsEarned: 0,
    totalExperienceEarned: 0
  };
  
  // Helper function to check all achievements
  export const checkAchievements = (gameState, setGameState, context = {}) => {
    const newAchievements = [];
    
    achievementList.forEach(achievement => {
      // Skip if already achieved
      if (gameState.achievements.includes(achievement.id)) {
        return;
      }
      
      // Skip if hidden and prerequisite not met
      if (achievement.hidden) {
        const prerequisitesMet = checkPrerequisites(achievement.id, gameState.achievements);
        if (!prerequisitesMet) {
          return;
        }
      }
      
      // Check if condition is met
      if (achievement.condition(gameState, context)) {
        newAchievements.push(achievement);
      }
    });
    
    // Apply rewards and update state
    if (newAchievements.length > 0) {
      setGameState(prev => {
        const newState = { ...prev };
        
        newAchievements.forEach(achievement => {
          // Add to achievements list
          newState.achievements.push(achievement.id);
          
          // Apply rewards
          if (achievement.reward.coins) {
            newState.player.coins += achievement.reward.coins;
          }
          if (achievement.reward.experience) {
            newState.player.experience += achievement.reward.experience;
          }
          
          // Add floating text for achievement
          newState.floatingTexts.push({
            x: 400,
            y: 200,
            text: `Achievement: ${achievement.name}!`,
            color: '#ffd700',
            life: 3000,
            maxLife: 3000,
            alpha: 1
          });
        });
        
        return newState;
      });
    }
    
    return newAchievements;
  };
  
  // Check if prerequisites for hidden achievements are met
  const checkPrerequisites = (achievementId, unlockedAchievements) => {
    switch (achievementId) {
      case 'combo_20':
        return unlockedAchievements.includes('combo_10');
      case 'rich_1000':
        return unlockedAchievements.includes('rich');
      default:
        return true;
    }
  };
  
  // Get achievement by ID
  export const getAchievementById = (achievementId) => {
    return achievementList.find(a => a.id === achievementId);
  };
  
  // Get all unlocked achievements
  export const getUnlockedAchievements = (achievementIds) => {
    return achievementList.filter(a => achievementIds.includes(a.id));
  };
  
  // Get achievement progress percentage
  export const getAchievementProgress = (gameState) => {
    const total = achievementList.length;
    const unlocked = gameState.achievements.length;
    return Math.floor((unlocked / total) * 100);
  };
  
  // Get achievements by category
  export const getAchievementsByCategory = (category) => {
    return achievementList.filter(a => a.category === category);
  };
  
  // Reset achievement progress (for new game)
  export const resetAchievementProgress = () => {
    return {
      speedKillsTimer: 0,
      speedKillsCount: 0,
      waveStartHealth: 100,
      waveEnemiesKilled: 0,
      waveDamageTaken: 0,
      purchasedItems: [],
      totalCoinsEarned: 0,
      totalExperienceEarned: 0
    };
  };
  
  export default achievementList;

---

File: src\game\constants\gameConstants.js

// Game configuration and constants
export const GAME_CONFIG = {
    CANVAS_WIDTH: 800,
    CANVAS_HEIGHT: 600,
    FPS: 60,
    DELTA_TIME: 16, // milliseconds per frame at 60fps
    
    // Player defaults
    PLAYER_INITIAL_X: 400,
    PLAYER_INITIAL_Y: 300,
    PLAYER_SIZE: 30,
    PLAYER_BASE_SPEED: 3,
    PLAYER_BASE_HEALTH: 100,
    PLAYER_BASE_MANA: 100,
    PLAYER_BASE_DAMAGE: 25,
    PLAYER_BASE_CRIT_CHANCE: 0.1,
    PLAYER_BASE_CRIT_MULTIPLIER: 2,
    
    // Mana regeneration
    MANA_REGEN_RATE: 0.1,
    
    // Combat
    KNOCKBACK_FORCE_PLAYER: 20,
    KNOCKBACK_FORCE_ENEMY: 15,
    
    // Wave system
    INITIAL_ENEMY_COUNT: 3,
    WAVE_TIMER_DURATION: 20000, // 20 seconds
    WAVE_TIMER_MIN: 5000, // 5 seconds minimum before next wave
    ENEMY_SPAWN_DELAY: 500, // milliseconds between enemy spawns
    
    // Effects
    DAMAGE_FLASH_DURATION: 200,
    COMBO_TIMER_DURATION: 3000,
    
    // Spawn chances
    POWERUP_SPAWN_CHANCE: 0.0008,
  };
  
  // Initial game state factory
  export const getInitialGameState = () => ({
    player: {
      x: GAME_CONFIG.PLAYER_INITIAL_X,
      y: GAME_CONFIG.PLAYER_INITIAL_Y,
      health: GAME_CONFIG.PLAYER_BASE_HEALTH,
      maxHealth: GAME_CONFIG.PLAYER_BASE_HEALTH,
      mana: GAME_CONFIG.PLAYER_BASE_MANA,
      maxMana: GAME_CONFIG.PLAYER_BASE_MANA,
      level: 1,
      experience: 0,
      experienceToNext: 100,
      speed: GAME_CONFIG.PLAYER_BASE_SPEED,
      damage: GAME_CONFIG.PLAYER_BASE_DAMAGE,
      critChance: GAME_CONFIG.PLAYER_BASE_CRIT_CHANCE,
      critMultiplier: GAME_CONFIG.PLAYER_BASE_CRIT_MULTIPLIER,
      coins: 0
    },
    enemies: [],
    powerups: [],
    projectiles: [],
    particles: [],
    floatingTexts: [],
    explosions: [],
    wave: 1,
    waveTimer: 0,
    enemiesKilled: 0,
    gameActive: true,
    isPaused: false,
    score: 0,
    gameTime: 0,
    combo: 0,
    comboTimer: 0,
    shopOpen: false,
    achievements: []
  });
  
  // Initial abilities state factory
  export const getInitialAbilities = () => ({
    fireball: {
      cooldown: 0,
      maxCooldown: 800,
      damage: 30,
      manaCost: 15,
      level: 1,
      projectileSpeed: 12,
      range: 200
    },
    heal: {
      cooldown: 0,
      maxCooldown: 3000,
      healAmount: 40,
      manaCost: 25,
      level: 1
    },
    shield: {
      cooldown: 0,
      maxCooldown: 8000,
      duration: 0,
      maxDuration: 3000,
      manaCost: 30,
      level: 1
    },
    lightning: {
      cooldown: 0,
      maxCooldown: 2000,
      damage: 60,
      manaCost: 40,
      level: 1,
      range: 200
    },
    meteor: {
      cooldown: 0,
      maxCooldown: 5000,
      damage: 100,
      manaCost: 60,
      level: 1,
      warningDuration: 1000,
      explosionRadius: 80
    },
    freeze: {
      cooldown: 0,
      maxCooldown: 4000,
      duration: 2000,
      manaCost: 35,
      level: 1
    }
  });
  
  // Enemy type definitions
  export const ENEMY_TYPES = {
    slime: {
      health: 40,
      speed: 1.2,
      damage: 15,
      color: '#44ff44',
      points: 100,
      size: 20,
      spawnWeight: 0.4,
      minWave: 1
    },
    orc: {
      health: 80,
      speed: 1.8,
      damage: 25,
      color: '#ff4444',
      points: 150,
      size: 25,
      spawnWeight: 0.3,
      minWave: 2
    },
    golem: {
      health: 150,
      speed: 0.8,
      damage: 40,
      color: '#888888',
      points: 250,
      size: 35,
      spawnWeight: 0.2,
      minWave: 3
    },
    demon: {
      health: 100,
      speed: 2.5,
      damage: 35,
      color: '#ff00ff',
      points: 300,
      size: 30,
      spawnWeight: 0.15,
      minWave: 4
    },
    boss: {
      health: 400,
      speed: 1.5,
      damage: 50,
      color: '#8800ff',
      points: 1000,
      size: 50,
      spawnWeight: 0.05,
      minWave: 5
    }
  };
  
  // Powerup type definitions
  export const POWERUP_TYPES = {
    health: {
      color: '#ff3333',
      effect: 'heal',
      value: 50,
      duration: 0,
      icon: '',
      description: 'Restore 50 HP'
    },
    mana: {
      color: '#3333ff',
      effect: 'mana',
      value: 40,
      duration: 0,
      icon: '',
      description: 'Restore 40 MP'
    },
    experience: {
      color: '#ffff33',
      effect: 'experience',
      value: 50,
      duration: 0,
      icon: '',
      description: 'Gain 50 XP'
    },
    speed: {
      color: '#33ff33',
      effect: 'tempSpeed',
      value: 1.5,
      duration: 8000,
      icon: '',
      description: 'Speed x1.5 for 8s'
    },
    damage: {
      color: '#ff8833',
      effect: 'tempDamage',
      value: 2,
      duration: 10000,
      icon: '',
      description: 'Damage x2 for 10s'
    }
  };
  
  // Level up configuration
  export const LEVEL_UP_BONUSES = {
    healthIncrease: 10,
    manaIncrease: 5,
    damageIncrease: 5,
    experienceMultiplier: 100 // experienceToNext = level * this value
  };
  
  // Visual effects configuration
  export const VISUAL_CONFIG = {
    PARTICLE_GRAVITY: 0.1,
    PARTICLE_AIR_RESISTANCE: 0.99,
    PARTICLE_DEFAULT_COUNT: 8,
    FLOATING_TEXT_RISE_SPEED: 1,
    POWERUP_PULSE_SPEED: 0.008,
    POWERUP_PULSE_AMPLITUDE: 0.2,
    POWERUP_BASE_SIZE: 15,
    SHIELD_DASH_PATTERN: [5, 5],
    CROSSHAIR_SIZE: 10,
    GRID_SIZE: 40,
    GRID_ALPHA: 0.3
  };
  
  // Colors used throughout the game
  export const COLORS = {
    // Background
    BG_GRADIENT_CENTER: '#1a1a2e',
    BG_GRADIENT_EDGE: '#0f0f1e',
    GRID: '#333',
    
    // Player
    PLAYER: '#0088ff',
    PLAYER_OUTLINE: '#ffffff',
    
    // Effects
    DAMAGE_TEXT: '#ff0000',
    HEAL_TEXT: '#00ff00',
    MANA_TEXT: '#0099ff',
    EXPERIENCE_TEXT: '#ffff00',
    COINS_TEXT: '#ffd700',
    COMBO_TEXT: '#ff8800',
    BLOCKED_TEXT: '#00ffff',
    CRITICAL_TEXT: '#ffff00',
    
    // UI
    HEALTH_BAR_BG: '#ff0000',
    HEALTH_BAR_FILL: '#00ff00',
    MANA_BAR_GRADIENT_START: '#0066ff',
    MANA_BAR_GRADIENT_END: '#00ccff',
    
    // Abilities
    FIREBALL: '#ff4400',
    LIGHTNING: '#ffff00',
    SHIELD: 'rgba(68, 255, 255, ',
    FREEZE: '#00ffff',
    METEOR: '#ff4400',
    
    // Misc
    ENEMY_OUTLINE: '#000000',
    WHITE: '#ffffff',
    BLACK: '#000000'
  };
  
  // Input key mappings
  export const KEY_BINDINGS = {
    MOVE_UP: 'w',
    MOVE_LEFT: 'a',
    MOVE_DOWN: 's',
    MOVE_RIGHT: 'd',
    HEAL: ' ',
    LIGHTNING: 'q',
    SHIELD: 'e',
    PAUSE: 'p',
    RESTART: 'r'
  };
  
  // Game state keys for easier refactoring
  export const GAME_STATES = {
    ACTIVE: 'active',
    PAUSED: 'paused',
    GAME_OVER: 'gameOver'
  };
  
  // Spawn positions for enemies
  export const SPAWN_POSITIONS = {
    TOP: 0,
    RIGHT: 1,
    BOTTOM: 2,
    LEFT: 3
  };

---

File: src\game\constants\shopItems.js

// Shop items configuration
// Each item has a unique ID, name, description, price, and type
// Types: 'permanent' (player stat upgrades), 'ability' (ability upgrades), 'unlock' (new abilities)

export const SHOP_ITEM_TYPES = {
    PERMANENT: 'permanent',
    ABILITY: 'ability',
    UNLOCK: 'unlock'
  };
  
  export const shopItems = [
    // Permanent upgrades (Player stats)
    {
      id: 'health_upgrade',
      name: 'Health Boost',
      description: '+20 Max Health',
      price: 100,
      type: SHOP_ITEM_TYPES.PERMANENT,
      icon: '',
      effect: {
        stat: 'maxHealth',
        value: 20,
        alsoHeal: true // Fully heal when purchasing
      }
    },
    {
      id: 'mana_upgrade',
      name: 'Mana Boost',
      description: '+15 Max Mana',
      price: 80,
      type: SHOP_ITEM_TYPES.PERMANENT,
      icon: '',
      effect: {
        stat: 'maxMana',
        value: 15,
        alsoRestore: true // Fully restore mana when purchasing
      }
    },
    {
      id: 'speed_upgrade',
      name: 'Speed Boost',
      description: '+0.5 Movement Speed',
      price: 120,
      type: SHOP_ITEM_TYPES.PERMANENT,
      icon: '',
      effect: {
        stat: 'speed',
        value: 0.5
      }
    },
    {
      id: 'crit_upgrade',
      name: 'Critical Strike',
      description: '+5% Crit Chance',
      price: 150,
      type: SHOP_ITEM_TYPES.PERMANENT,
      icon: '',
      effect: {
        stat: 'critChance',
        value: 0.05
      }
    },
    {
      id: 'damage_upgrade',
      name: 'Damage Boost',
      description: '+10 Base Damage',
      price: 140,
      type: SHOP_ITEM_TYPES.PERMANENT,
      icon: '',
      effect: {
        stat: 'damage',
        value: 10
      }
    },
  
    // Ability upgrades
    {
      id: 'fireball_upgrade',
      name: 'Fireball Mastery',
      description: '+10 Damage, -200ms Cooldown',
      price: 200,
      type: SHOP_ITEM_TYPES.ABILITY,
      icon: '',
      abilityId: 'fireball',
      effect: {
        damage: 10,
        cooldownReduction: 200 // milliseconds
      }
    },
    {
      id: 'heal_upgrade',
      name: 'Healing Mastery',
      description: '+15 Healing, -500ms Cooldown',
      price: 180,
      type: SHOP_ITEM_TYPES.ABILITY,
      icon: '',
      abilityId: 'heal',
      effect: {
        healAmount: 15,
        cooldownReduction: 500
      }
    },
    {
      id: 'lightning_upgrade',
      name: 'Lightning Mastery',
      description: '+20 Damage, Chain 2 Enemies',
      price: 250,
      type: SHOP_ITEM_TYPES.ABILITY,
      icon: '',
      abilityId: 'lightning',
      effect: {
        damage: 20,
        chainCount: 2 // New feature: hit multiple enemies
      }
    },
    {
      id: 'shield_upgrade',
      name: 'Shield Mastery',
      description: '+1s Duration, -1s Cooldown',
      price: 220,
      type: SHOP_ITEM_TYPES.ABILITY,
      icon: '',
      abilityId: 'shield',
      effect: {
        durationIncrease: 1000, // milliseconds
        cooldownReduction: 1000
      }
    },
  
    // Unlock new abilities
    {
      id: 'meteor_unlock',
      name: 'Meteor Spell',
      description: 'Unlock devastating area spell',
      price: 300,
      type: SHOP_ITEM_TYPES.UNLOCK,
      icon: '',
      abilityId: 'meteor',
      requiresLevel: 3
    },
    {
      id: 'freeze_unlock',
      name: 'Time Freeze',
      description: 'Unlock ability to freeze all enemies',
      price: 350,
      type: SHOP_ITEM_TYPES.UNLOCK,
      icon: '',
      abilityId: 'freeze',
      requiresLevel: 5
    }
  ];
  
  // Helper function to get shop item by ID
  export const getShopItemById = (itemId) => {
    return shopItems.find(item => item.id === itemId);
  };
  
  // Helper function to check if player can afford item
  export const canAffordItem = (playerCoins, itemPrice) => {
    return playerCoins >= itemPrice;
  };
  
  // Helper function to check if player meets level requirement
  export const meetsLevelRequirement = (playerLevel, item) => {
    return !item.requiresLevel || playerLevel >= item.requiresLevel;
  };
  
  // Helper function to check if item is already purchased (for unlocks)
  export const isItemPurchased = (itemId, purchasedItems) => {
    return purchasedItems.includes(itemId);
  };
  
  // Get all available items for a player
  export const getAvailableItems = (playerLevel, playerCoins, purchasedItems) => {
    return shopItems.filter(item => {
      // Skip if already purchased (for unlocks)
      if (item.type === SHOP_ITEM_TYPES.UNLOCK && isItemPurchased(item.id, purchasedItems)) {
        return false;
      }
      
      // Check level requirement
      if (!meetsLevelRequirement(playerLevel, item)) {
        return false;
      }
      
      return true;
    });
  };
  
  // Apply shop item effect to game state
  export const applyShopItemEffect = (item, gameState, setGameState, abilities, setAbilities) => {
    switch (item.type) {
      case SHOP_ITEM_TYPES.PERMANENT:
        // Apply permanent stat upgrade
        setGameState(prev => {
          const newState = { ...prev };
          const effect = item.effect;
          
          // Apply the stat change
          newState.player[effect.stat] += effect.value;
          
          // Handle special cases
          if (effect.alsoHeal) {
            newState.player.health = newState.player.maxHealth;
          }
          if (effect.alsoRestore) {
            newState.player.mana = newState.player.maxMana;
          }
          
          return newState;
        });
        break;
        
      case SHOP_ITEM_TYPES.ABILITY:
        // Apply ability upgrade
        setAbilities(prev => {
          const newAbilities = { ...prev };
          const ability = newAbilities[item.abilityId];
          const effect = item.effect;
          
          if (effect.damage) {
            ability.damage += effect.damage;
          }
          if (effect.healAmount) {
            ability.healAmount += effect.healAmount;
          }
          if (effect.cooldownReduction) {
            ability.maxCooldown = Math.max(100, ability.maxCooldown - effect.cooldownReduction);
          }
          if (effect.durationIncrease) {
            ability.maxDuration += effect.durationIncrease;
          }
          if (effect.chainCount) {
            ability.chainCount = (ability.chainCount || 0) + effect.chainCount;
          }
          
          ability.level += 1;
          
          return newAbilities;
        });
        break;
        
      case SHOP_ITEM_TYPES.UNLOCK:
        // Unlock new ability
        setAbilities(prev => {
          const newAbilities = { ...prev };
          const ability = newAbilities[item.abilityId];
          
          if (ability) {
            ability.unlocked = true;
          }
          
          return newAbilities;
        });
        break;
    }
  };
  
  export default shopItems;

---

File: src\game\entities\Enemy.js

// Enemy entity class with AI behavior
import { ENEMY_TYPES, GAME_CONFIG } from '../constants/gameConstants.js';

export class Enemy {
  constructor(type, position, wave = 1) {
    const enemyData = ENEMY_TYPES[type] || ENEMY_TYPES.slime;
    
    // Position
    this.x = position.x;
    this.y = position.y;
    
    // Enemy type and properties
    this.type = type;
    this.size = enemyData.size;
    this.color = enemyData.color;
    this.points = enemyData.points;
    
    // Stats that scale with wave
    this.health = enemyData.health + Math.floor(wave * 5);
    this.maxHealth = this.health;
    this.speed = enemyData.speed + (wave * 0.1);
    this.damage = enemyData.damage + Math.floor(wave * 2);
    
    // Store original speed for freeze effects
    this.originalSpeed = this.speed;
    
    // State
    this.isAlive = true;
    this.lastDamageTime = 0;
    this.frozen = 0;
    
    // Unique ID for tracking
    this.id = `${type}_${Date.now()}_${Math.random()}`;
    
    // Movement
    this.velocity = { x: 0, y: 0 };
    
    // AI state
    this.aiState = 'chase'; // 'chase', 'flee', 'wander'
    this.aiTimer = 0;
  }

  // Update enemy AI and movement
  update(deltaTime, playerPosition, enemies) {
    // Update timers
    if (this.lastDamageTime > 0) {
      this.lastDamageTime -= deltaTime;
    }
    
    // Handle freeze effect
    if (this.frozen > 0) {
      this.frozen -= deltaTime;
      if (this.frozen <= 0) {
        this.speed = this.originalSpeed;
        this.frozen = 0;
      }
      return; // Don't move while frozen
    }
    
    // AI behavior based on enemy type
    this.updateAI(deltaTime, playerPosition, enemies);
    
    // Apply movement
    this.x += this.velocity.x;
    this.y += this.velocity.y;
    
    // Keep enemy in bounds (with some margin to allow entry from edges)
    const margin = this.size;
    this.x = Math.max(-margin, Math.min(GAME_CONFIG.CANVAS_WIDTH + margin, this.x));
    this.y = Math.max(-margin, Math.min(GAME_CONFIG.CANVAS_HEIGHT + margin, this.y));
  }

  // Update AI behavior
  updateAI(deltaTime, playerPosition, enemies) {
    switch (this.type) {
      case 'slime':
        this.basicChaseAI(playerPosition);
        break;
        
      case 'orc':
        this.aggressiveChaseAI(playerPosition);
        break;
        
      case 'golem':
        this.tankAI(playerPosition, deltaTime);
        break;
        
      case 'demon':
        this.erraticAI(playerPosition, deltaTime);
        break;
        
      case 'boss':
        this.bossAI(playerPosition, enemies, deltaTime);
        break;
        
      default:
        this.basicChaseAI(playerPosition);
    }
  }

  // Basic chase AI - moves directly toward player
  basicChaseAI(playerPosition) {
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      this.velocity.x = normalizedDx * this.speed;
      this.velocity.y = normalizedDy * this.speed;
    } else {
      this.velocity.x = 0;
      this.velocity.y = 0;
    }
  }

  // Aggressive chase - faster when player is far
  aggressiveChaseAI(playerPosition) {
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      // Speed up when far from player
      const speedMultiplier = distance > 200 ? 1.5 : 1;
      
      this.velocity.x = normalizedDx * this.speed * speedMultiplier;
      this.velocity.y = normalizedDy * this.speed * speedMultiplier;
    }
  }

  // Tank AI - slow but steady, occasional charge
  tankAI(playerPosition, deltaTime) {
    this.aiTimer += deltaTime;
    
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Charge every 3 seconds if close enough
    const isCharging = this.aiTimer % 3000 < 500 && distance < 150;
    
    if (distance > 1) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      const currentSpeed = isCharging ? this.speed * 2.5 : this.speed;
      
      this.velocity.x = normalizedDx * currentSpeed;
      this.velocity.y = normalizedDy * currentSpeed;
    }
  }

  // Erratic AI - unpredictable movement
  erraticAI(playerPosition, deltaTime) {
    this.aiTimer += deltaTime;
    
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 1) {
      let normalizedDx = dx / distance;
      let normalizedDy = dy / distance;
      
      // Add random movement every 0.5 seconds
      if (this.aiTimer > 500) {
        this.aiTimer = 0;
        const randomAngle = (Math.random() - 0.5) * Math.PI * 0.5;
        const cos = Math.cos(randomAngle);
        const sin = Math.sin(randomAngle);
        
        const newDx = normalizedDx * cos - normalizedDy * sin;
        const newDy = normalizedDx * sin + normalizedDy * cos;
        
        normalizedDx = newDx;
        normalizedDy = newDy;
      }
      
      this.velocity.x = normalizedDx * this.speed;
      this.velocity.y = normalizedDy * this.speed;
    }
  }

  // Boss AI - complex behavior
  bossAI(playerPosition, enemies, deltaTime) {
    this.aiTimer += deltaTime;
    
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Phase based on health
    const healthPercent = this.health / this.maxHealth;
    
    if (healthPercent > 0.5) {
      // Phase 1: Normal chase with occasional retreats
      if (this.aiTimer % 4000 < 3000) {
        this.basicChaseAI(playerPosition);
      } else {
        // Retreat
        if (distance > 1) {
          const normalizedDx = dx / distance;
          const normalizedDy = dy / distance;
          
          this.velocity.x = -normalizedDx * this.speed * 0.5;
          this.velocity.y = -normalizedDy * this.speed * 0.5;
        }
      }
    } else {
      // Phase 2: Aggressive with speed boost
      const speedBoost = 1.5;
      this.speed = this.originalSpeed * speedBoost;
      this.aggressiveChaseAI(playerPosition);
    }
  }

  // Take damage
  takeDamage(amount) {
    console.log(`${this.constructor.name} taking ${amount} damage. Health before: ${this.health}`);
    if (!this.isAlive) return 0;
    
    const actualDamage = Math.min(this.health, amount);
    this.health -= actualDamage;
    this.lastDamageTime = GAME_CONFIG.DAMAGE_FLASH_DURATION;
    
    if (this.health <= 0) {
      this.health = 0;
      this.isAlive = false;
    }
    console.log(`Health after: ${this.health}`);
    return actualDamage;
  }

  // Apply freeze effect
  freeze(duration) {
    this.frozen = duration;
    this.originalSpeed = this.speed;
    this.speed = 0;
  }

  // Apply knockback
  knockback(fromX, fromY, force) {
    const dx = this.x - fromX;
    const dy = this.y - fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 0) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      this.x += normalizedDx * force;
      this.y += normalizedDy * force;
    }
  }

  // Check if enemy should flash (damage indicator)
  shouldFlash() {
    return this.lastDamageTime > 0;
  }

  // Get enemy bounds for collision
  getBounds() {
    const halfSize = this.size / 2;
    return {
      left: this.x - halfSize,
      right: this.x + halfSize,
      top: this.y - halfSize,
      bottom: this.y + halfSize,
      centerX: this.x,
      centerY: this.y,
      radius: halfSize
    };
  }

  // Get loot drop
  getLoot() {
    const loot = {
      points: this.points,
      experience: Math.floor(this.points / 10),
      coins: Math.floor(this.points / 20) + Math.floor(Math.random() * 3)
    };
    
    // Boss drops more loot
    if (this.type === 'boss') {
      loot.coins *= 2;
      loot.experience *= 2;
    }
    
    return loot;
  }

  // Check if enemy is on screen (for optimization)
  isOnScreen() {
    const margin = 50;
    return this.x > -margin && 
           this.x < GAME_CONFIG.CANVAS_WIDTH + margin &&
           this.y > -margin && 
           this.y < GAME_CONFIG.CANVAS_HEIGHT + margin;
  }

  // Get state for serialization
  getState() {
    return {
      id: this.id,
      type: this.type,
      x: this.x,
      y: this.y,
      health: this.health,
      maxHealth: this.maxHealth,
      speed: this.speed,
      damage: this.damage,
      frozen: this.frozen,
      isAlive: this.isAlive
    };
  }
}

// Factory function to create enemy from spawn point
export function createEnemy(wave) {
  // Filter enemy types based on current wave
  const availableTypes = Object.entries(ENEMY_TYPES).filter(
    ([_, type]) => wave >= type.minWave
  );

  // Weighted random selection
  const totalWeight = availableTypes.reduce((sum, [_, type]) => sum + type.spawnWeight, 0);
  let random = Math.random() * totalWeight;
  let selectedType = 'slime';

  for (const [typeName, type] of availableTypes) {
    random -= type.spawnWeight;
    if (random <= 0) {
      selectedType = typeName;
      break;
    }
  }

  // Random spawn position from edges
  const side = Math.floor(Math.random() * 4);
  let x, y;
  
  switch(side) {
    case 0: // Top
      x = Math.random() * GAME_CONFIG.CANVAS_WIDTH;
      y = -30;
      break;
    case 1: // Right
      x = GAME_CONFIG.CANVAS_WIDTH + 30;
      y = Math.random() * GAME_CONFIG.CANVAS_HEIGHT;
      break;
    case 2: // Bottom
      x = Math.random() * GAME_CONFIG.CANVAS_WIDTH;
      y = GAME_CONFIG.CANVAS_HEIGHT + 30;
      break;
    case 3: // Left
      x = -30;
      y = Math.random() * GAME_CONFIG.CANVAS_HEIGHT;
      break;
  }

  return new Enemy(selectedType, { x, y }, wave);
}

export default Enemy;

---

File: src\game\entities\Particle.js

// Particle effects system for visual feedback
import { VISUAL_CONFIG, COLORS } from '../constants/gameConstants.js';

export class Particle {
  constructor(config) {
    // Position and movement
    this.x = config.x;
    this.y = config.y;
    this.vx = config.vx || (Math.random() - 0.5) * 6;
    this.vy = config.vy || (Math.random() - 0.5) * 6 - 2;
    
    // Visual properties
    this.color = config.color || '#ffffff';
    this.size = config.size || 3;
    this.shape = config.shape || 'circle'; // 'circle', 'square', 'star', 'spark'
    
    // Lifetime
    this.life = config.life || 1 + Math.random();
    this.maxLife = this.life;
    
    // Physics properties
    this.gravity = config.gravity !== undefined ? config.gravity : VISUAL_CONFIG.PARTICLE_GRAVITY;
    this.friction = config.friction !== undefined ? config.friction : VISUAL_CONFIG.PARTICLE_AIR_RESISTANCE;
    this.bounce = config.bounce || 0;
    this.spin = config.spin || 0;
    this.angle = config.angle || 0;
    
    // Special effects
    this.glow = config.glow || false;
    this.trail = config.trail || false;
    this.fadeOut = config.fadeOut !== undefined ? config.fadeOut : true;
    this.shrink = config.shrink || false;
    this.colorShift = config.colorShift || null; // { targetColor, speed }
    
    // State
    this.isActive = true;
    this.alpha = 1;
    
    // Trail history for special effects
    if (this.trail) {
      this.trailPositions = [];
      this.maxTrailLength = 5;
    }
  }

  // Update particle physics and state
  update(deltaTime) {
    if (!this.isActive) return;
    
    const dt = deltaTime / 1000; // Convert to seconds
    
    // Update lifetime
    this.life -= dt;
    if (this.life <= 0) {
      this.isActive = false;
      return;
    }
    
    // Apply physics
    this.vy += this.gravity;
    this.vx *= this.friction;
    this.vy *= this.friction;
    
    // Update position
    this.x += this.vx;
    this.y += this.vy;
    
    // Update rotation
    if (this.spin !== 0) {
      this.angle += this.spin * dt;
    }
    
    // Update trail
    if (this.trail) {
      this.updateTrail();
    }
    
    // Visual effects
    if (this.fadeOut) {
      this.alpha = this.life / this.maxLife;
    }
    
    if (this.shrink) {
      this.size = this.size * (this.life / this.maxLife);
    }
    
    if (this.colorShift) {
      this.updateColorShift(dt);
    }
    
    // Bounce off bottom (optional)
    if (this.bounce > 0 && this.y > 580) {
      this.y = 580;
      this.vy *= -this.bounce;
    }
  }

  // Update trail positions
  updateTrail() {
    this.trailPositions.push({ x: this.x, y: this.y, alpha: this.alpha });
    
    if (this.trailPositions.length > this.maxTrailLength) {
      this.trailPositions.shift();
    }
    
    // Fade trail
    this.trailPositions.forEach((pos, index) => {
      pos.alpha = (index / this.trailPositions.length) * this.alpha;
    });
  }

  // Update color shift effect
  updateColorShift(dt) {
    // Simple color interpolation (could be improved)
    // This is a placeholder - real color interpolation would be more complex
    this.color = this.colorShift.targetColor;
  }

  // Render the particle
  render(ctx) {
    if (!this.isActive || this.alpha <= 0) return;
    
    ctx.save();
    ctx.globalAlpha = this.alpha;
    
    // Draw trail first
    if (this.trail && this.trailPositions.length > 0) {
      this.renderTrail(ctx);
    }
    
    // Apply glow effect
    if (this.glow) {
      ctx.shadowColor = this.color;
      ctx.shadowBlur = this.size * 2;
    }
    
    // Transform for rotation
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    // Draw particle shape
    ctx.fillStyle = this.color;
    
    switch (this.shape) {
      case 'circle':
        this.renderCircle(ctx);
        break;
      case 'square':
        this.renderSquare(ctx);
        break;
      case 'star':
        this.renderStar(ctx);
        break;
      case 'spark':
        this.renderSpark(ctx);
        break;
      default:
        this.renderCircle(ctx);
    }
    
    ctx.restore();
  }

  // Render shapes
  renderCircle(ctx) {
    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fill();
  }

  renderSquare(ctx) {
    const halfSize = this.size / 2;
    ctx.fillRect(-halfSize, -halfSize, this.size, this.size);
  }

  renderStar(ctx) {
    const spikes = 5;
    const outerRadius = this.size;
    const innerRadius = this.size / 2;
    
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = (i * Math.PI) / spikes;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    ctx.fill();
  }

  renderSpark(ctx) {
    // Elongated particle to show motion
    const length = this.size * 3;
    const width = this.size / 2;
    
    ctx.beginPath();
    ctx.ellipse(0, 0, length, width, Math.atan2(this.vy, this.vx), 0, Math.PI * 2);
    ctx.fill();
  }

  renderTrail(ctx) {
    this.trailPositions.forEach((pos, index) => {
      ctx.fillStyle = this.color;
      ctx.globalAlpha = pos.alpha;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, this.size * (index / this.trailPositions.length), 0, Math.PI * 2);
      ctx.fill();
    });
  }
}

// Particle system manager
export class ParticleSystem {
  constructor() {
    this.particles = [];
    this.emitters = new Map();
  }

  // Add a single particle
  addParticle(particle) {
    this.particles.push(particle);
  }

  // Create multiple particles at once
  createParticles(x, y, color, count = 8, options = {}) {
    for (let i = 0; i < count; i++) {
      const particle = new Particle({
        x,
        y,
        color,
        ...options,
        // Add some randomness
        vx: options.vx || (Math.random() - 0.5) * 6,
        vy: options.vy || (Math.random() - 0.5) * 6 - 2,
        life: options.life || 1 + Math.random()
      });
      
      this.particles.push(particle);
    }
  }

  // Create an emitter for continuous particles
  createEmitter(id, config) {
    const emitter = {
      id,
      x: config.x,
      y: config.y,
      rate: config.rate || 10, // particles per second
      particleConfig: config.particleConfig || {},
      active: true,
      accumulator: 0
    };
    
    this.emitters.set(id, emitter);
    return emitter;
  }

  // Update all particles and emitters
  update(deltaTime) {
    // Update existing particles
    this.particles = this.particles.filter(particle => {
      particle.update(deltaTime);
      return particle.isActive;
    });
    
    // Update emitters
    this.emitters.forEach(emitter => {
      if (!emitter.active) return;
      
      emitter.accumulator += deltaTime;
      const particlesToEmit = Math.floor(emitter.accumulator / (1000 / emitter.rate));
      
      if (particlesToEmit > 0) {
        emitter.accumulator -= particlesToEmit * (1000 / emitter.rate);
        
        for (let i = 0; i < particlesToEmit; i++) {
          this.addParticle(new Particle({
            x: emitter.x,
            y: emitter.y,
            ...emitter.particleConfig
          }));
        }
      }
    });
  }

  // Render all particles
  render(ctx) {
    this.particles.forEach(particle => {
      particle.render(ctx);
    });
  }

  // Remove an emitter
  removeEmitter(id) {
    this.emitters.delete(id);
  }

  // Clear all particles
  clear() {
    this.particles = [];
    this.emitters.clear();
  }

  // Get particle count
  getCount() {
    return this.particles.length;
  }
}

// Preset particle effects
export const ParticleEffects = {
  // Explosion effect
  explosion(x, y, color = '#ff4400', intensity = 1) {
    const particles = [];
    const count = Math.floor(20 * intensity);
    
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 3 + Math.random() * 5 * intensity;
      
      particles.push(new Particle({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        color,
        size: 2 + Math.random() * 3,
        life: 0.5 + Math.random() * 0.5,
        glow: true,
        gravity: 0,
        friction: 0.95
      }));
    }
    
    return particles;
  },

  // Hit effect
  hit(x, y, color = '#ffffff') {
    const particles = [];
    
    for (let i = 0; i < 6; i++) {
      particles.push(new Particle({
        x, y,
        color,
        size: 2 + Math.random() * 2,
        shape: 'spark',
        life: 0.3 + Math.random() * 0.3
      }));
    }
    
    return particles;
  },

  // Heal effect
  heal(x, y) {
    const particles = [];
    
    for (let i = 0; i < 10; i++) {
      const angle = (Math.PI * 2 * i) / 10;
      
      particles.push(new Particle({
        x, y,
        vx: Math.cos(angle) * 2,
        vy: Math.sin(angle) * 2 - 3,
        color: '#00ff00',
        size: 3,
        shape: 'star',
        life: 1,
        glow: true,
        gravity: -0.1, // Float up
        fadeOut: true
      }));
    }
    
    return particles;
  },

  // Level up effect
  levelUp(x, y) {
    const particles = [];
    const colors = ['#ffff00', '#ffd700', '#ffaa00'];
    
    for (let i = 0; i < 15; i++) {
      const angle = (Math.PI * 2 * i) / 15;
      const color = colors[Math.floor(Math.random() * colors.length)];
      
      particles.push(new Particle({
        x, y,
        vx: Math.cos(angle) * 4,
        vy: Math.sin(angle) * 4,
        color,
        size: 4,
        shape: 'star',
        life: 1.5,
        glow: true,
        spin: 0.2,
        trail: true
      }));
    }
    
    return particles;
  },

  // Magic cast effect
  magicCast(x, y, color = '#0099ff') {
    const particles = [];
    
    for (let i = 0; i < 12; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = 20 + Math.random() * 10;
      
      particles.push(new Particle({
        x: x + Math.cos(angle) * distance,
        y: y + Math.sin(angle) * distance,
        vx: -Math.cos(angle) * 2,
        vy: -Math.sin(angle) * 2,
        color,
        size: 2,
        life: 0.5,
        glow: true,
        trail: true
      }));
    }
    
    return particles;
  },

  // Coin collect effect
  coinCollect(x, y) {
    const particles = [];
    
    for (let i = 0; i < 8; i++) {
      particles.push(new Particle({
        x, y,
        vx: (Math.random() - 0.5) * 4,
        vy: -Math.random() * 4 - 2,
        color: '#ffd700',
        size: 3,
        shape: 'square',
        life: 0.8,
        glow: true,
        gravity: 0.3,
        bounce: 0.5
      }));
    }
    
    return particles;
  }
};

export default Particle;

---

File: src\game\entities\Player.js

// Player entity class with proper state management
import { GAME_CONFIG, LEVEL_UP_BONUSES } from '../constants/gameConstants.js';

export class Player {
  constructor(initialState = {}) {
    // Initialize with default values or provided state
    this.x = initialState.x || GAME_CONFIG.PLAYER_INITIAL_X;
    this.y = initialState.y || GAME_CONFIG.PLAYER_INITIAL_Y;
    this.health = initialState.health || GAME_CONFIG.PLAYER_BASE_HEALTH;
    this.maxHealth = initialState.maxHealth || GAME_CONFIG.PLAYER_BASE_HEALTH;
    this.mana = initialState.mana || GAME_CONFIG.PLAYER_BASE_MANA;
    this.maxMana = initialState.maxMana || GAME_CONFIG.PLAYER_BASE_MANA;
    this.level = initialState.level || 1;
    this.experience = initialState.experience || 0;
    this.experienceToNext = initialState.experienceToNext || 100;
    this.speed = initialState.speed || GAME_CONFIG.PLAYER_BASE_SPEED;
    this.damage = initialState.damage || GAME_CONFIG.PLAYER_BASE_DAMAGE;
    this.critChance = initialState.critChance || GAME_CONFIG.PLAYER_BASE_CRIT_CHANCE;
    this.critMultiplier = initialState.critMultiplier || GAME_CONFIG.PLAYER_BASE_CRIT_MULTIPLIER;
    this.coins = initialState.coins || 0;
    
    // Temporary effects
    this.tempEffects = {
      speedMultiplier: 1,
      damageMultiplier: 1,
      speedDuration: 0,
      damageDuration: 0
    };
    
    // Movement state
    this.velocity = { x: 0, y: 0 };
  }

  // Update player movement based on input
  updateMovement(keys, deltaTime) {
    let dx = 0;
    let dy = 0;

    if (keys.w) dy -= 1;
    if (keys.s) dy += 1;
    if (keys.a) dx -= 1;
    if (keys.d) dx += 1;

    // Normalize diagonal movement
    if (dx !== 0 && dy !== 0) {
      dx *= 0.707;
      dy *= 0.707;
    }

    // Apply speed with temporary effects
    const effectiveSpeed = this.speed * this.tempEffects.speedMultiplier;
    this.velocity.x = dx * effectiveSpeed;
    this.velocity.y = dy * effectiveSpeed;

    // Update position with bounds checking
    this.x = Math.max(
      GAME_CONFIG.PLAYER_SIZE / 2,
      Math.min(GAME_CONFIG.CANVAS_WIDTH - GAME_CONFIG.PLAYER_SIZE / 2, 
               this.x + this.velocity.x)
    );
    this.y = Math.max(
      GAME_CONFIG.PLAYER_SIZE / 2,
      Math.min(GAME_CONFIG.CANVAS_HEIGHT - GAME_CONFIG.PLAYER_SIZE / 2, 
               this.y + this.velocity.y)
    );
  }

  // Update temporary effects
  updateTempEffects(deltaTime) {
    if (this.tempEffects.speedDuration > 0) {
      this.tempEffects.speedDuration -= deltaTime;
      if (this.tempEffects.speedDuration <= 0) {
        this.tempEffects.speedMultiplier = 1;
      }
    }

    if (this.tempEffects.damageDuration > 0) {
      this.tempEffects.damageDuration -= deltaTime;
      if (this.tempEffects.damageDuration <= 0) {
        this.tempEffects.damageMultiplier = 1;
      }
    }
  }

  // Auto-regenerate mana
  regenerateMana(deltaTime) {
    if (this.mana < this.maxMana) {
      this.mana = Math.min(this.maxMana, this.mana + GAME_CONFIG.MANA_REGEN_RATE);
    }
  }

  // Main update method
  update(keys, deltaTime) {
    this.updateMovement(keys, deltaTime);
    this.updateTempEffects(deltaTime);
    this.regenerateMana(deltaTime);
  }

  // Take damage with knockback
  takeDamage(amount, enemyPosition) {
    const actualDamage = Math.max(0, amount);
    this.health = Math.max(0, this.health - actualDamage);

    // Calculate knockback
    const dx = this.x - enemyPosition.x;
    const dy = this.y - enemyPosition.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > 0) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;

      // Apply knockback
      this.x += normalizedDx * GAME_CONFIG.KNOCKBACK_FORCE_PLAYER;
      this.y += normalizedDy * GAME_CONFIG.KNOCKBACK_FORCE_PLAYER;

      // Keep player in bounds
      this.x = Math.max(
        GAME_CONFIG.PLAYER_SIZE / 2,
        Math.min(GAME_CONFIG.CANVAS_WIDTH - GAME_CONFIG.PLAYER_SIZE / 2, this.x)
      );
      this.y = Math.max(
        GAME_CONFIG.PLAYER_SIZE / 2,
        Math.min(GAME_CONFIG.CANVAS_HEIGHT - GAME_CONFIG.PLAYER_SIZE / 2, this.y)
      );
    }

    return actualDamage;
  }

  // Heal the player
  heal(amount) {
    const actualHeal = Math.min(amount, this.maxHealth - this.health);
    this.health = Math.min(this.maxHealth, this.health + amount);
    return actualHeal;
  }

  restoreMana(amount) {
    if (!this.isAlive()) return 0; // Can't restore mana if not alive
    const actualRestore = Math.min(amount, this.maxMana - this.mana);
    this.mana = Math.min(this.maxMana, this.mana + amount); // Ensure you don't exceed maxMana
    return actualRestore; // Return the amount actually restored
  }

  // Make sure useMana is also robust
  useMana(amount) {
    if (this.mana >= amount) {
      this.mana -= amount;
      return true;
    }
    return false;
  }

  // Add experience and check for level up
  addExperience(amount) {
    this.experience += amount;
    let levelsGained = 0;

    while (this.experience >= this.experienceToNext) {
      this.experience -= this.experienceToNext;
      this.level += 1;
      levelsGained += 1;
      this.experienceToNext = this.level * LEVEL_UP_BONUSES.experienceMultiplier;

      // Apply level up bonuses
      this.maxHealth += LEVEL_UP_BONUSES.healthIncrease;
      this.health = this.maxHealth; // Full heal on level up
      this.maxMana += LEVEL_UP_BONUSES.manaIncrease;
      this.mana = this.maxMana; // Full mana restore on level up
      this.damage += LEVEL_UP_BONUSES.damageIncrease;
    }

    return levelsGained;
  }

  // Add coins
  addCoins(amount) {
    this.coins += amount;
    return this.coins;
  }

  // Spend coins
  spendCoins(amount) {
    if (this.coins >= amount) {
      this.coins -= amount;
      return true;
    }
    return false;
  }

  // Apply temporary effect
  applyTempEffect(type, multiplier, duration) {
    switch (type) {
      case 'speed':
        this.tempEffects.speedMultiplier = multiplier;
        this.tempEffects.speedDuration = duration;
        break;
      case 'damage':
        this.tempEffects.damageMultiplier = multiplier;
        this.tempEffects.damageDuration = duration;
        break;
    }
  }

  // Get effective damage (with temp effects and crit)
  getEffectiveDamage() {
    let damage = this.damage * this.tempEffects.damageMultiplier;
    
    // Check for critical hit
    const isCrit = Math.random() < this.critChance;
    if (isCrit) {
      damage *= this.critMultiplier;
    }

    return {
      damage: Math.floor(damage),
      isCrit
    };
  }

  // Check if player is alive
  isAlive() {
    return this.health > 0;
  }

  // Get player state for saving/serialization
  getState() {
    return {
      x: this.x,
      y: this.y,
      health: this.health,
      maxHealth: this.maxHealth,
      mana: this.mana,
      maxMana: this.maxMana,
      level: this.level,
      experience: this.experience,
      experienceToNext: this.experienceToNext,
      speed: this.speed,
      damage: this.damage,
      critChance: this.critChance,
      critMultiplier: this.critMultiplier,
      coins: this.coins
    };
  }

  // Reset player to initial state
  reset(initialState = {}) {
    this.x = initialState.x || GAME_CONFIG.PLAYER_INITIAL_X;
    this.y = initialState.y || GAME_CONFIG.PLAYER_INITIAL_Y;
    this.health = initialState.health || GAME_CONFIG.PLAYER_BASE_HEALTH;
    this.maxHealth = initialState.maxHealth || GAME_CONFIG.PLAYER_BASE_HEALTH;
    this.mana = initialState.mana || GAME_CONFIG.PLAYER_BASE_MANA;
    this.maxMana = initialState.maxMana || GAME_CONFIG.PLAYER_BASE_MANA;
    this.level = initialState.level || 1;
    this.experience = initialState.experience || 0;
    this.experienceToNext = initialState.experienceToNext || 100;
    this.speed = initialState.speed || GAME_CONFIG.PLAYER_BASE_SPEED;
    this.damage = initialState.damage || GAME_CONFIG.PLAYER_BASE_DAMAGE;
    this.critChance = initialState.critChance || GAME_CONFIG.PLAYER_BASE_CRIT_CHANCE;
    this.critMultiplier = initialState.critMultiplier || GAME_CONFIG.PLAYER_BASE_CRIT_MULTIPLIER;
    this.coins = initialState.coins || 0;
    
    // Reset temporary effects
    this.tempEffects = {
      speedMultiplier: 1,
      damageMultiplier: 1,
      speedDuration: 0,
      damageDuration: 0
    };
    
    this.velocity = { x: 0, y: 0 };
  }
}

export default Player;

---

File: src\game\entities\Powerup.js

// Powerup entity class
import { POWERUP_TYPES, VISUAL_CONFIG, GAME_CONFIG } from '../constants/gameConstants.js';

export class Powerup {
  constructor(type, position) {
    const powerupData = POWERUP_TYPES[type] || POWERUP_TYPES.health;
    
    // Position
    this.x = position.x;
    this.y = position.y;
    
    // Type and properties
    this.type = type;
    this.color = powerupData.color;
    this.effect = powerupData.effect;
    this.value = powerupData.value;
    this.duration = powerupData.duration;
    this.icon = powerupData.icon;
    this.description = powerupData.description;
    
    // Visual properties
    this.size = VISUAL_CONFIG.POWERUP_BASE_SIZE;
    this.pulsePhase = Math.random() * Math.PI * 2; // Random start phase for pulse
    this.bobPhase = Math.random() * Math.PI * 2; // Random start phase for bobbing
    this.rotation = 0;
    this.glowIntensity = 0;
    
    // State
    this.isActive = true;
    this.lifetime = 10000; // 10 seconds before disappearing
    this.fadeStartTime = 8000; // Start fading after 8 seconds
    
    // Physics (optional floating movement)
    this.vx = 0;
    this.vy = 0;
    this.targetX = this.x;
    this.targetY = this.y;
    
    // Attraction to player
    this.attractionRadius = 100;
    this.attractionSpeed = 3;
    this.isAttracted = false;
    
    // Unique ID
    this.id = `powerup_${type}_${Date.now()}_${Math.random()}`;
  }

  // Update powerup state
  update(deltaTime, playerPosition) {
    if (!this.isActive) return;
    
    // Update lifetime
    this.lifetime -= deltaTime;
    if (this.lifetime <= 0) {
      this.isActive = false;
      return;
    }
    
    // Update visual effects
    this.updateVisualEffects(deltaTime);
    
    // Check attraction to player
    if (playerPosition) {
      this.updateAttraction(playerPosition, deltaTime);
    }
    
    // Update position
    this.x += this.vx;
    this.y += this.vy;
    
    // Apply friction
    this.vx *= 0.95;
    this.vy *= 0.95;
  }

  // Update visual effects
  updateVisualEffects(deltaTime) {
    const time = Date.now() * 0.001; // Convert to seconds
    
    // Pulse effect
    this.pulsePhase = time * VISUAL_CONFIG.POWERUP_PULSE_SPEED;
    
    // Bobbing effect
    this.bobPhase = time * 2;
    
    // Rotation
    this.rotation += deltaTime * 0.001;
    
    // Glow intensity based on lifetime
    if (this.lifetime < this.fadeStartTime) {
      this.glowIntensity = Math.sin(time * 10) * 0.5 + 0.5; // Fast pulsing when about to disappear
    } else {
      this.glowIntensity = Math.sin(time * 3) * 0.3 + 0.7; // Gentle pulsing
    }
  }

  // Update attraction to player
  updateAttraction(playerPosition, deltaTime) {
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Start attraction when player is close
    if (distance < this.attractionRadius) {
      this.isAttracted = true;
    }
    
    // Once attracted, move toward player
    if (this.isAttracted && distance > 5) {
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      // Accelerate toward player
      const speed = this.attractionSpeed * (1 - distance / this.attractionRadius);
      this.vx += normalizedDx * speed;
      this.vy += normalizedDy * speed;
      
      // Limit max velocity
      const maxSpeed = 8;
      const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
      if (currentSpeed > maxSpeed) {
        this.vx = (this.vx / currentSpeed) * maxSpeed;
        this.vy = (this.vy / currentSpeed) * maxSpeed;
      }
    }
  }

  // Get visual properties for rendering
  getVisualProperties() {
    // Calculate pulse size
    const pulse = Math.sin(this.pulsePhase) * VISUAL_CONFIG.POWERUP_PULSE_AMPLITUDE + 1;
    const size = this.size * pulse;
    
    // Calculate bob offset
    const bobOffset = Math.sin(this.bobPhase) * 3;
    
    // Calculate alpha based on lifetime
    let alpha = 1;
    if (this.lifetime < 2000) {
      alpha = this.lifetime / 2000;
    }
    
    return {
      x: this.x,
      y: this.y + bobOffset,
      size,
      color: this.color,
      rotation: this.rotation,
      alpha,
      glowIntensity: this.glowIntensity * 10,
      isFlashing: this.lifetime < this.fadeStartTime
    };
  }

  // Check if powerup can be collected
  canCollect(playerPosition) {
    if (!this.isActive) return false;
    
    const dx = playerPosition.x - this.x;
    const dy = playerPosition.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    const collectionRadius = 25; // Slightly larger than visual size
    return distance < collectionRadius;
  }

  // Get collection effect data
  getCollectionEffect() {
    return {
      type: this.effect,
      value: this.value,
      duration: this.duration,
      color: this.color,
      icon: this.icon,
      description: this.description
    };
  }

  // Apply effect to player
  applyEffect(player, tempEffectsRef) {
    switch (this.effect) {
      case 'heal':
        return {
          type: 'heal',
          amount: player.heal(this.value),
          message: `+${this.value} HP`
        };
        
      case 'mana':
        return {
          type: 'mana',
          amount: player.restoreMana(this.value),
          message: `+${this.value} MP`
        };
        
      case 'experience':
        player.addExperience(this.value);
        return {
          type: 'experience',
          amount: this.value,
          message: `+${this.value} XP`
        };
        
      case 'tempSpeed':
        player.applyTempEffect('speed', this.value, this.duration);
        return {
          type: 'buff',
          effect: 'speed',
          message: 'SPEED UP!'
        };
        
      case 'tempDamage':
        player.applyTempEffect('damage', this.value, this.duration);
        return {
          type: 'buff',
          effect: 'damage',
          message: 'DAMAGE UP!'
        };
        
      default:
        return {
          type: 'unknown',
          message: 'Collected!'
        };
    }
  }

  // Get bounds for collision
  getBounds() {
    return {
      centerX: this.x,
      centerY: this.y,
      radius: 15
    };
  }

  // Get state for serialization
  getState() {
    return {
      id: this.id,
      type: this.type,
      x: this.x,
      y: this.y,
      lifetime: this.lifetime,
      isActive: this.isActive
    };
  }
}

// Factory function to create random powerup
export function createRandomPowerup(position) {
  const types = Object.keys(POWERUP_TYPES);
  const weights = {
    health: 0.3,
    mana: 0.25,
    experience: 0.25,
    speed: 0.1,
    damage: 0.1
  };
  
  // Weighted random selection
  let random = Math.random();
  let selectedType = 'health';
  
  for (const type of types) {
    random -= weights[type] || 0.2;
    if (random <= 0) {
      selectedType = type;
      break;
    }
  }
  
  return new Powerup(selectedType, position);
}

// Spawn powerup at random position
export function spawnPowerupRandom() {
  const margin = 50;
  const position = {
    x: margin + Math.random() * (GAME_CONFIG.CANVAS_WIDTH - margin * 2),
    y: margin + Math.random() * (GAME_CONFIG.CANVAS_HEIGHT - margin * 2)
  };
  
  return createRandomPowerup(position);
}

// Spawn powerup from defeated enemy
export function spawnPowerupFromEnemy(enemy) {
  // Chance to spawn powerup based on enemy type
  const dropChances = {
    slime: 0.1,
    orc: 0.15,
    golem: 0.2,
    demon: 0.25,
    boss: 0.5
  };
  
  const dropChance = dropChances[enemy.type] || 0.1;
  
  if (Math.random() < dropChance) {
    return createRandomPowerup({ x: enemy.x, y: enemy.y });
  }
  
  return null;
}

// Powerup manager class
export class PowerupManager {
  constructor() {
    this.powerups = [];
    this.spawnTimer = 0;
    this.spawnInterval = 15000; // Spawn every 15 seconds
    this.maxPowerups = 5;
  }

  // Update all powerups
  update(deltaTime, playerPosition) {
    // Update existing powerups
    this.powerups = this.powerups.filter(powerup => {
      powerup.update(deltaTime, playerPosition);
      return powerup.isActive;
    });
    
    // Update spawn timer
    this.spawnTimer += deltaTime;
    
    // Spawn new powerup if needed
    if (this.spawnTimer >= this.spawnInterval && this.powerups.length < this.maxPowerups) {
      this.spawnTimer = 0;
      this.spawnPowerup();
    }
  }

  // Spawn a new powerup
  spawnPowerup() {
    const powerup = spawnPowerupRandom();
    this.powerups.push(powerup);
  }

  // Add powerup from external source (like enemy death)
  addPowerup(powerup) {
    if (powerup && this.powerups.length < this.maxPowerups * 2) {
      this.powerups.push(powerup);
    }
  }

  // Check collection with player
  checkCollection(playerPosition, player, tempEffectsRef) {
    const collected = [];
    
    this.powerups = this.powerups.filter(powerup => {
      if (powerup.canCollect(playerPosition)) {
        const effect = powerup.applyEffect(player, tempEffectsRef);
        collected.push({
          powerup,
          effect,
          position: { x: powerup.x, y: powerup.y }
        });
        return false; // Remove from array
      }
      return true; // Keep in array
    });
    
    return collected;
  }

  // Render all powerups
  render(ctx) {
    this.powerups.forEach(powerup => {
      const visual = powerup.getVisualProperties();
      
      ctx.save();
      ctx.globalAlpha = visual.alpha;
      
      // Draw glow
      if (visual.glowIntensity > 0) {
        ctx.shadowColor = visual.color;
        ctx.shadowBlur = visual.glowIntensity;
      }
      
      // Draw powerup
      ctx.fillStyle = visual.color;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      
      ctx.translate(visual.x, visual.y);
      ctx.rotate(visual.rotation);
      
      // Draw shape
      ctx.beginPath();
      ctx.arc(0, 0, visual.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Draw icon (simplified)
      ctx.fillStyle = '#ffffff';
      ctx.font = `${visual.size}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(powerup.icon, 0, 0);
      
      ctx.restore();
    });
  }

  // Clear all powerups
  clear() {
    this.powerups = [];
    this.spawnTimer = 0;
  }

  // Get powerup count
  getCount() {
    return this.powerups.length;
  }
}

export default Powerup;

---

File: src\game\entities\Projectile.js

// src/game/entities/Projectile.js
import { GAME_CONFIG } from "../constants/gameConstants"; // If needed for bounds, etc.

export class Projectile {
  constructor(x, y, vx, vy, damage, color, life, type = 'default', size = 6) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.damage = damage;
    this.color = color;
    this.life = life; // in milliseconds
    this.type = type; // e.g., 'fireball', 'meteor_impact'
    this.size = size;
    this.isActive = true;
    this.id = Date.now() + Math.random();
    this.explosionRadius = (type === 'meteor') ? 80 : 0; // Example specific property
  }

  update(deltaTime) {
    this.x += this.vx;
    this.y += this.vy;
    this.life -= deltaTime;

    // Basic boundary check
    if (this.life <= 0 ||
        this.x < -this.size || this.x > GAME_CONFIG.CANVAS_WIDTH + this.size ||
        this.y < -this.size || this.y > GAME_CONFIG.CANVAS_HEIGHT + this.size) {
      this.isActive = false;
    }
  }

  // Check hit with an enemy (simple circle collision)
  checkHit(enemy) {
    if (!this.isActive || !enemy || !enemy.isAlive) return false; // Added !enemy check
    const dx = this.x - enemy.x;
    const dy = this.y - enemy.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const enemyRadius = enemy.size ? enemy.size / 2 : 10; // Default if enemy.size undefined
    const hit = distance < enemyRadius + this.size;

    if (hit && this.type !== 'meteor') { // Meteor impact (area damage) might not deactivate projectile itself
        this.isActive = false; // Standard projectiles disappear on hit
    }
    return hit;
  }

  getVisualProperties() {
    return {
      x: this.x,
      y: this.y,
      size: this.size,
      color: this.color,
      alpha: Math.max(0, this.life / 2000), // Example: base max life for alpha calculation
      rotation: Math.atan2(this.vy, this.vx),
      glowIntensity: 10,
      trail: this.type === 'fireball'
    };
  }
}

export const ProjectileFactory = {
  createFireball: (startX, startY, targetX, targetY, damage, projectileSpeed = 12, color = '#ff4400', life = 2000) => {
    const dx = targetX - startX;
    const dy = targetY - startY;
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0) distance = 1; // Avoid division by zero if target is same as start

    return new Projectile(
      startX, startY,
      (dx / distance) * projectileSpeed,
      (dy / distance) * projectileSpeed,
      damage, color, life, 'fireball'
    );
  },
  createMeteorImpact: (targetX, targetY, damage, color = '#ff4400', life = 100) => {
    // This projectile represents the impact itself, for area damage check
    return new Projectile(
        targetX, targetY,
        0,0, // No velocity, it's an instant impact effect
        damage, color, life,
        'meteor', 80 // Meteor impact radius as size for collision check
    );
  },
  createLightning: (startX, startY, targetEnemy, damage, color = '#FFFF00', life = 300, speed = 30) => {
    // Lightning strikes quickly towards the target
    const dx = targetEnemy.x - startX;
    const dy = targetEnemy.y - startY;
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0) distance = 1; // Avoid division by zero

    // We might want a different visual or behavior for lightning
    // For now, a fast projectile. Could also be an "instant" effect where no projectile object is needed,
    // and damage is applied directly in AbilityManager.
    return new Projectile(
      startX, startY,
      (dx / distance) * speed, // Very fast
      (dy / distance) * speed,
      damage, color, life, // Short life
      'lightning', 4 // Smaller size for lightning bolt visual
    );
  }
};

---

File: src\game\hooks\useAbilities.js

// src/game/hooks/useAbilities.js
import { useState, useCallback, useRef, useEffect } from 'react';
import { getInitialAbilities } from '../constants/gameConstants';
import AbilityManager from '../abilities/AbilityManager'; // We'll need to make sure AbilityManager is correctly imported

export const useAbilities = (currentAbilities, setAbilitiesDirectly, playerRef, currentGameState, setGameStateDirectly) => {
  // Note: currentAbilities and setAbilitiesDirectly are passed from useGameState
  // This hook will primarily manage the AbilityManager instance and provide casting functions.

  const abilityManagerRef = useRef(null);

  // Initialize or update AbilityManager instance
  useEffect(() => {
    if (!abilityManagerRef.current) {
      // Pass the setAbilitiesDirectly function from useGameState to AbilityManager
      abilityManagerRef.current = new AbilityManager(currentAbilities, setAbilitiesDirectly);
    } else {
      // If AbilityManager needs to update its internal abilities state when 'currentAbilities' prop changes
      abilityManagerRef.current.abilities = currentAbilities;
      // Also update the setter if it changes, though unlikely for a top-level setter
      abilityManagerRef.current.setAbilities = setAbilitiesDirectly;
    }
  }, [currentAbilities, setAbilitiesDirectly]);

  const update = useCallback((deltaTime) => {
    if (abilityManagerRef.current) {
      const changed = abilityManagerRef.current.update(deltaTime);
      // If AbilityManager's update method directly mutates its 'abilities'
      // and we want to reflect that change in the React state managed by useGameState,
      // we might need to trigger setAbilitiesDirectly here if 'changed' is true.
      // However, AbilityManager is already constructed with setAbilitiesDirectly,
      // so it should be calling it internally when cooldowns change.
      // This 'changed' flag from AbilityManager.update might be redundant if it already calls setAbilitiesDirectly.
    }
  }, []); // Dependencies might be needed if AbilityManager interaction changes

  const cast = useCallback((abilityName, target) => {
    if (playerRef.current && abilityManagerRef.current && currentGameState && setGameStateDirectly) {
      // Ensure playerRef.current.useMana and other methods exist and are callable
      // Ensure currentGameState.enemies exists
      const castResult = abilityManagerRef.current.cast(
        abilityName,
        playerRef.current, // The Player class instance
        target,
        currentGameState // The whole gameState for context if needed by abilities
      );

      if (castResult) {
        // Player mana should have been handled by AbilityManager.cast calling player.useMana
        // The AbilityManager's cast method itself should trigger setAbilities for cooldowns.

        // Now, handle side effects of the cast like adding projectiles, particles to the main gameState
        setGameStateDirectly(prevGameState => {
          const newState = { ...prevGameState };
          if (castResult.projectile) {
            newState.projectiles = [...(newState.projectiles || []), castResult.projectile];
          }
          if (castResult.particles && castResult.particles.length > 0) {
            newState.particles = [...(newState.particles || []), ...castResult.particles];
          }
          if (castResult.floatingText) {
            newState.floatingTexts = [...(newState.floatingTexts || []), castResult.floatingText];
          }
          // Handle other potential castResult properties (e.g., buffs to player, delayed effects)
          // For example, if a shield is cast, abilityManager.cast might directly modify ability.duration,
          // and then AbilityManager.update would trigger setAbilities.
          return newState;
        });
      }
      // Return the result in case the caller needs to know if casting was successful or had specific outcomes
      return castResult;
    }
    return null; // Indicate casting failed or prerequisites not met
  }, [playerRef, currentGameState, setGameStateDirectly]); // Add abilityManagerRef.current to dependencies if its methods are redefined

  // Return the manager instance and its methods
  // The `abilities` state itself is managed by `useGameState` and passed into this hook.
  // This hook provides the *logic* to interact with those abilities.
  return {
    updateAbilities: update,
    castAbility: cast,
    abilityManager: abilityManagerRef.current, // Expose the manager instance if needed directly
  };
};

---

File: src\game\hooks\useGameState.js

import { useState, useEffect, useRef, useCallback } from 'react';
import { getInitialGameState, getInitialAbilities } from '../constants/gameConstants.js';
import { Player } from '../entities/Player.js'; // Assuming Player.js uses: export class Player
import { getGameLoop, resetGameLoop } from '../systems/GameLoop.js';
import { checkAchievements, resetAchievementProgress } from '../constants/achievements.js';

export function useGameState() {
  const [gameState, setGameState] = useState(getInitialGameState);
  const [abilities, setAbilities] = useState(getInitialAbilities); // Added abilities state here
  const [isLoading, setIsLoading] = useState(true); // Start with loading true

  const playerRef = useRef(null);
  const gameLoopRef = useRef(null); // This will be the GameLoop class instance
  const inputRef = useRef({ w: false, a: false, s: false, d: false });
  const mouseRef = useRef({ x: 400, y: 300, down: false });
  const achievementProgressRef = useRef(resetAchievementProgress());

  const cleanupRef = useRef({
    timers: new Set(),
    listeners: new Map()
  });

  // Initialize player entity AND GameLoop
  useEffect(() => {
    // Initialize Player
    if (!playerRef.current) {
      console.log("Initializing Player in useGameState useEffect...");
      playerRef.current = new Player(gameState.player); // gameState.player is from initial state
      // After initializing, we might want to ensure a re-render if UltimatePixelGame depends on it.
      // Often, the first game loop update or another state change will trigger this.
    }

    // Initialize GameLoop (moved here for better control)
    if (!gameLoopRef.current) {
        console.log("Initializing GameLoop in useGameState useEffect...");
        gameLoopRef.current = getGameLoop(); // Get or create the singleton
    }
    setIsLoading(false); // Player and GameLoop refs should be set now

    // Cleanup for the game loop instance when the component unmounts
    // Or when useGameState is no longer used.
    return () => {
        if (gameLoopRef.current && gameLoopRef.current.isRunning) {
            console.log("Stopping GameLoop from useGameState cleanup...");
            gameLoopRef.current.stop();
        }
        // gameLoopRef.current.destroy(); // If you have a destroy method to nullify instance
    };
  }, []); // Empty dependency array: runs once after initial render.

  // Update player entity's internal state when gameState.player changes from outside (e.g. loading saved game)
  useEffect(() => {
    if (playerRef.current && gameState.player) {
      // This is more for synchronizing if gameState.player is set externally,
      // not for changes originating from playerRef.current methods.
      const pState = gameState.player;
      playerRef.current.x = pState.x;
      playerRef.current.y = pState.y;
      playerRef.current.health = pState.health;
      playerRef.current.maxHealth = pState.maxHealth;
      playerRef.current.mana = pState.mana;
      playerRef.current.maxMana = pState.maxMana;
      playerRef.current.level = pState.level;
      playerRef.current.experience = pState.experience;
      playerRef.current.experienceToNext = pState.experienceToNext;
      playerRef.current.speed = pState.speed;
      playerRef.current.damage = pState.damage;
      playerRef.current.critChance = pState.critChance;
      playerRef.current.critMultiplier = pState.critMultiplier;
      playerRef.current.coins = pState.coins;
    }
  }, [gameState.player]); // Runs when gameState.player object reference changes

  // Safe timer/listener management (keep as is)
  const addTimer = useCallback((callback, delay) => { /* ... */ }, []);
  const addInterval = useCallback((callback, interval) => { /* ... */ }, []);
  const clearTimer = useCallback((timerId) => { /* ... */ }, []);
  const clearAllTimers = useCallback(() => { /* ... */ }, []);
  const addEventListener = useCallback((element, event, handler) => { /* ... */ }, []);
  const removeEventListener = useCallback((element, event, handler) => { /* ... */ }, []);
  const clearAllEventListeners = useCallback(() => { /* ... */ }, []);


  // Update game state WITH the player's current state from the Player object
  const syncPlayerState = useCallback(() => {
    if (playerRef.current) {
      setGameState(prev => {
        const currentPlayerState = playerRef.current.getState();
        // Only update if there's an actual change to prevent infinite loops
        if (JSON.stringify(prev.player) !== JSON.stringify(currentPlayerState)) {
          return { ...prev, player: currentPlayerState };
        }
        return prev;
      });
    }
  }, []); // Dependencies: setGameState, playerRef

  // Update abilities cooldowns - This should be handled by AbilityManager which calls setAbilities directly
  // const updateAbilitiesState = useCallback((deltaTime) => { ... }, [setAbilities]);
  // We will rely on the updateAbilitiesLogic from useAbilities hook to call AbilityManager.update


  const checkAndUnlockAchievements = useCallback((context = {}) => { /* ... */ }, [gameState, setGameState]);

  const pauseGame = useCallback(() => {
    setGameState(prev => ({ ...prev, isPaused: true }));
    if (gameLoopRef.current) {
      gameLoopRef.current.pause();
    }
  }, [gameLoopRef]); // Removed setGameState from deps as it's stable

  const resumeGame = useCallback(() => {
    setGameState(prev => ({ ...prev, isPaused: false }));
    if (gameLoopRef.current) {
      gameLoopRef.current.resume();
    }
  }, [gameLoopRef]); // Removed setGameState from deps

  const restartGame = useCallback(() => {
    setIsLoading(true);
    console.log("Restarting game...");

    if (gameLoopRef.current) {
      console.log("Stopping current game loop for restart...");
      gameLoopRef.current.stop(); // Stop it
      // gameLoopRef.current.reset(); // or reset it if it clears callbacks
    }
    
    clearAllTimers();
    clearAllEventListeners(); // Assuming these are correctly implemented

    const newInitialGameState = getInitialGameState();
    setGameState(newInitialGameState);
    setAbilities(getInitialAbilities());

    if (playerRef.current) {
      console.log("Resetting player entity...");
      playerRef.current.reset(newInitialGameState.player);
    } else {
      console.log("Re-initializing player entity for restart...");
      playerRef.current = new Player(newInitialGameState.player);
    }

    achievementProgressRef.current = resetAchievementProgress();
    inputRef.current = { w: false, a: false, s: false, d: false };
    mouseRef.current = { x: 400, y: 300, down: false };

    // Ensure we get a fresh loop instance that's not already running
    // gameLoopRef.current = resetGameLoop(); // This creates a new instance
    // Or, if getGameLoop is a true singleton that can be reset and restarted:
    if (gameLoopRef.current) {
        gameLoopRef.current.reset(); // Ensure it's ready for new init/start
    } else {
        gameLoopRef.current = getGameLoop();
    }


    // The game loop should be started by the component that uses it (e.g., GameCanvas)
    // once it has the update/render functions.
    console.log("Game state reset. Waiting for GameCanvas to start loop.");
    setIsLoading(false);
  }, [clearAllTimers, clearAllEventListeners, gameLoopRef]); // Added gameLoopRef

  // Cleanup on unmount of the component using this hook
  useEffect(() => {
    return () => {
      console.log("useGameState unmounting - cleaning up timers and listeners.");
      clearAllTimers();
      clearAllEventListeners();
      if (gameLoopRef.current) {
        console.log("Destroying GameLoop from useGameState unmount cleanup.");
        gameLoopRef.current.destroy(); // Ensure this method exists and cleans up the loop
        gameLoopRef.current = null; // Help with GC
      }
    };
  }, [clearAllTimers, clearAllEventListeners]);


  return {
    gameState,
    setGameState,
    abilities,         // Pass abilities state
    setAbilities,      // Pass abilities setter
    isLoading,
    playerRef,
    gameLoopRef,       // Pass the gameLoopRef
    inputRef,
    mouseRef,
    achievementProgressRef,
    addTimer,
    addInterval,
    clearTimer,
    syncPlayerState,
    // updateAbilities: updateAbilitiesState, // Renamed to avoid confusion with the one from useAbilities
    checkAndUnlockAchievements,
    pauseGame,
    resumeGame,
    restartGame
  };
}

export function useGameInput(inputRef, mouseRef, canvasRef) {
  const handleKeyDown = useCallback((e) => {
    switch(e.key.toLowerCase()) {
      case 'w': inputRef.current.w = true; break;
      case 'a': inputRef.current.a = true; break;
      case 's': inputRef.current.s = true; break;
      case 'd': inputRef.current.d = true; break;
    }
  }, [inputRef]);

  const handleKeyUp = useCallback((e) => {
    switch(e.key.toLowerCase()) {
      case 'w': inputRef.current.w = false; break;
      case 'a': inputRef.current.a = false; break;
      case 's': inputRef.current.s = false; break;
      case 'd': inputRef.current.d = false; break;
    }
  }, [inputRef]);

  const handleMouseMove = useCallback((e) => {
    if (canvasRef.current) {
      const rect = canvasRef.current.getBoundingClientRect();
      mouseRef.current.x = e.clientX - rect.left;
      mouseRef.current.y = e.clientY - rect.top;
    }
  }, [mouseRef, canvasRef]);

  const handleMouseDown = useCallback((e) => {
    mouseRef.current.down = true;
  }, [mouseRef]);

  const handleMouseUp = useCallback((e) => {
    mouseRef.current.down = false;
  }, [mouseRef]);

  // Setup and cleanup
  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    if (canvasRef.current) {
      canvasRef.current.addEventListener('mousemove', handleMouseMove);
      canvasRef.current.addEventListener('mousedown', handleMouseDown);
      canvasRef.current.addEventListener('mouseup', handleMouseUp);
    }

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      
      if (canvasRef.current) {
        canvasRef.current.removeEventListener('mousemove', handleMouseMove);
        canvasRef.current.removeEventListener('mousedown', handleMouseDown);
        canvasRef.current.removeEventListener('mouseup', handleMouseUp);
      }
    };
  }, [handleKeyDown, handleKeyUp, handleMouseMove, handleMouseDown, handleMouseUp, canvasRef]);
}

---

File: src\game\rendering\EffectsRenderer.js



---

File: src\game\rendering\GameRenderer.js



---

File: src\game\rendering\UIRenderer.js



---

File: src\game\systems\AchievementSystem.js



---

File: src\game\systems\CollisionSystem.js

// Collision detection and resolution system
import { GAME_CONFIG } from '../constants/gameConstants.js';

export class CollisionSystem {
  constructor() {
    // Collision event callbacks
    this.callbacks = {
      playerEnemy: null,
      projectileEnemy: null,
      playerPowerup: null,
      explosionEnemy: null,
      enemyEnemy: null
    };
    
    // Spatial grid for optimization (optional)
    this.useGrid = true;
    this.gridSize = 100;
    this.grid = new Map();
  }

  // Register collision callbacks
  onPlayerEnemyCollision(callback) {
    this.callbacks.playerEnemy = callback;
  }

  onProjectileEnemyCollision(callback) {
    this.callbacks.projectileEnemy = callback;
  }

  onPlayerPowerupCollision(callback) {
    this.callbacks.playerPowerup = callback;
  }

  onExplosionEnemyCollision(callback) {
    this.callbacks.explosionEnemy = callback;
  }

  onEnemyEnemyCollision(callback) {
    this.callbacks.enemyEnemy = callback;
  }

  // Main collision check method
  checkCollisions(gameState, player, abilities) { // gameState is the full React gameState
    // No need for internal collisions object, just call callbacks directly
    // if (this.useGrid) { this.updateGrid(gameState, player); } // Grid can be complex, skip for now

    // Player vs Enemies
    if (this.callbacks.playerEnemy) {
      const playerBounds = this.getPlayerBounds(player);
      const hasShield = abilities.shield && abilities.shield.duration > 0;
      (gameState.enemies || []).forEach(enemy => {
        if (!enemy.isAlive) return;
        const enemyBounds = enemy.getBounds();
        if (this.checkCircleCollision(playerBounds, enemyBounds)) {
          this.callbacks.playerEnemy({ player, enemy, hasShield });
        }
      });
    }

    // Projectiles vs Enemies
    if (this.callbacks.projectileEnemy) {
      (gameState.projectiles || []).forEach(projectile => {
        if (!projectile.isActive) return;
        (gameState.enemies || []).forEach(enemy => {
          if (!enemy.isAlive) return;
          if (projectile.checkHit(enemy)) { // projectile.checkHit also marks itself inactive
            this.callbacks.projectileEnemy({ projectile, enemy });
          }
        });
      });
    }

    // Player vs Powerups
    if (this.callbacks.playerPowerup) {
        const playerBounds = this.getPlayerBounds(player);
        (gameState.powerups || []).forEach((powerup, index) => { // Index might not be needed if using ID
            if (!powerup.isActive) return;
            const powerupBounds = powerup.getBounds ? powerup.getBounds() : this.getPowerupBounds(powerup); // Use powerup's own getBounds if available
            if (this.checkCircleCollision(playerBounds, powerupBounds)) {
                this.callbacks.playerPowerup({ player, powerup });
            }
        });
    }

    // Explosions vs Enemies
    if (this.callbacks.explosionEnemy) {
        (gameState.explosions || []).forEach(explosion => {
            (gameState.enemies || []).forEach(enemy => {
                if (!enemy.isAlive) return;
                const dx = enemy.x - explosion.x;
                const dy = enemy.y - explosion.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < explosion.radius) {
                    const damagePercent = Math.max(0, 1 - (distance / explosion.radius));
                    this.callbacks.explosionEnemy({ explosion, enemy, distance, damagePercent });
                }
            });
        });
    }
    // No return needed as callbacks modify state via setGameState
  }

  // ... (checkCircleCollision, getPlayerBounds, getPowerupBounds as before)
  // Make sure getPowerupBounds is defined if Powerup class doesn't have its own getBounds
  getPowerupBounds(powerup) { // Add this if not present
    return {
      centerX: powerup.x,
      centerY: powerup.y,
      radius: powerup.size ? powerup.size / 2 : 15 // or a fixed collection radius
    };
  }

  // Check collisions between player and enemies
  checkPlayerEnemyCollisions(player, enemies, abilities, collisions) {
    const playerBounds = this.getPlayerBounds(player);
    
    // Check shield protection
    const hasShield = abilities.shield && abilities.shield.duration > 0;
    
    enemies.forEach(enemy => {
      if (!enemy.isAlive) return;
      
      const enemyBounds = enemy.getBounds();
      
      if (this.checkCircleCollision(playerBounds, enemyBounds)) {
        collisions.playerEnemy.push({
          player,
          enemy,
          hasShield
        });
      }
    });
  }

  // Check collisions between projectiles and enemies
  checkProjectileEnemyCollisions(projectiles, enemies, collisions) {
    projectiles.forEach(projectile => {
      if (!projectile.isActive) return;
      
      enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        
        if (projectile.checkHit(enemy)) {
          collisions.projectileEnemy.push({
            projectile,
            enemy,
            damage: projectile.damage
          });
        }
      });
    });
  }

  // Check collisions between player and powerups
  checkPlayerPowerupCollisions(player, powerups, collisions) {
    const playerBounds = this.getPlayerBounds(player);
    
    powerups.forEach((powerup, index) => {
      const powerupBounds = this.getPowerupBounds(powerup);
      
      if (this.checkCircleCollision(playerBounds, powerupBounds)) {
        collisions.playerPowerup.push({
          player,
          powerup,
          index
        });
      }
    });
  }

  // Check collisions between explosions and enemies
  checkExplosionEnemyCollisions(explosions, enemies, collisions) {
    explosions.forEach(explosion => {
      enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        
        const dx = enemy.x - explosion.x;
        const dy = enemy.y - explosion.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < explosion.radius) {
          const damagePercent = 1 - (distance / explosion.radius);
          collisions.explosionEnemy.push({
            explosion,
            enemy,
            distance,
            damagePercent
          });
        }
      });
    });
  }

  // Check enemy vs enemy collisions (for separation)
  checkEnemyEnemyCollisions(enemies, collisions) {
    for (let i = 0; i < enemies.length; i++) {
      const enemy1 = enemies[i];
      if (!enemy1.isAlive) continue;
      
      for (let j = i + 1; j < enemies.length; j++) {
        const enemy2 = enemies[j];
        if (!enemy2.isAlive) continue;
        
        const bounds1 = enemy1.getBounds();
        const bounds2 = enemy2.getBounds();
        
        if (this.checkCircleCollision(bounds1, bounds2)) {
          collisions.enemyEnemy.push({
            enemy1,
            enemy2
          });
        }
      }
    }
  }

  // Execute collision callbacks
  executeCallbacks(collisions, gameState) {
    // Player-Enemy collisions
    if (this.callbacks.playerEnemy && collisions.playerEnemy.length > 0) {
      collisions.playerEnemy.forEach(collision => {
        this.callbacks.playerEnemy(collision, gameState);
      });
    }

    // Projectile-Enemy collisions
    if (this.callbacks.projectileEnemy && collisions.projectileEnemy.length > 0) {
      collisions.projectileEnemy.forEach(collision => {
        this.callbacks.projectileEnemy(collision, gameState);
      });
    }

    // Player-Powerup collisions
    if (this.callbacks.playerPowerup && collisions.playerPowerup.length > 0) {
      collisions.playerPowerup.forEach(collision => {
        this.callbacks.playerPowerup(collision, gameState);
      });
    }

    // Explosion-Enemy collisions
    if (this.callbacks.explosionEnemy && collisions.explosionEnemy.length > 0) {
      collisions.explosionEnemy.forEach(collision => {
        this.callbacks.explosionEnemy(collision, gameState);
      });
    }

    // Enemy-Enemy collisions
    if (this.callbacks.enemyEnemy && collisions.enemyEnemy.length > 0) {
      collisions.enemyEnemy.forEach(collision => {
        this.callbacks.enemyEnemy(collision, gameState);
      });
    }
  }

  // Circle collision check
  checkCircleCollision(bounds1, bounds2) {
    const dx = bounds1.centerX - bounds2.centerX;
    const dy = bounds1.centerY - bounds2.centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const minDistance = bounds1.radius + bounds2.radius;
    
    return distance < minDistance;
  }

  // AABB collision check (for rectangular objects)
  checkAABBCollision(bounds1, bounds2) {
    return bounds1.left < bounds2.right &&
           bounds1.right > bounds2.left &&
           bounds1.top < bounds2.bottom &&
           bounds1.bottom > bounds2.top;
  }

  // Get player bounds
  getPlayerBounds(player) {
    const halfSize = GAME_CONFIG.PLAYER_SIZE / 2;
    return {
      left: player.x - halfSize,
      right: player.x + halfSize,
      top: player.y - halfSize,
      bottom: player.y + halfSize,
      centerX: player.x,
      centerY: player.y,
      radius: halfSize
    };
  }

  // Get powerup bounds
  getPowerupBounds(powerup) {
    return {
      centerX: powerup.x,
      centerY: powerup.y,
      radius: 15
    };
  }

  // Update spatial grid for optimization
  updateGrid(gameState, player) {
    this.grid.clear();
    
    // Add player to grid
    this.addToGrid('player', player, player.x, player.y);
    
    // Add enemies to grid
    gameState.enemies.forEach(enemy => {
      if (enemy.isAlive) {
        this.addToGrid('enemy', enemy, enemy.x, enemy.y);
      }
    });
    
    // Add projectiles to grid
    gameState.projectiles.forEach(projectile => {
      if (projectile.isActive) {
        this.addToGrid('projectile', projectile, projectile.x, projectile.y);
      }
    });
    
    // Add powerups to grid
    gameState.powerups.forEach(powerup => {
      this.addToGrid('powerup', powerup, powerup.x, powerup.y);
    });
  }

  // Add entity to spatial grid
  addToGrid(type, entity, x, y) {
    const gridX = Math.floor(x / this.gridSize);
    const gridY = Math.floor(y / this.gridSize);
    const key = `${gridX},${gridY}`;
    
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    
    this.grid.get(key).push({ type, entity });
  }

  // Get nearby entities from grid
  getNearbyEntities(x, y, radius) {
    const entities = [];
    const gridRadius = Math.ceil(radius / this.gridSize);
    const centerGridX = Math.floor(x / this.gridSize);
    const centerGridY = Math.floor(y / this.gridSize);
    
    for (let dx = -gridRadius; dx <= gridRadius; dx++) {
      for (let dy = -gridRadius; dy <= gridRadius; dy++) {
        const key = `${centerGridX + dx},${centerGridY + dy}`;
        const cellEntities = this.grid.get(key);
        
        if (cellEntities) {
          entities.push(...cellEntities);
        }
      }
    }
    
    return entities;
  }

  // Helper method to resolve collision overlap
  static resolveOverlap(entity1, entity2, separationForce = 1) {
    const dx = entity1.x - entity2.x;
    const dy = entity1.y - entity2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) {
      // Entities are at exact same position, push in random direction
      const angle = Math.random() * Math.PI * 2;
      entity1.x += Math.cos(angle) * separationForce;
      entity1.y += Math.sin(angle) * separationForce;
    } else {
      // Push entities apart
      const normalX = dx / distance;
      const normalY = dy / distance;
      
      entity1.x += normalX * separationForce * 0.5;
      entity1.y += normalY * separationForce * 0.5;
      entity2.x -= normalX * separationForce * 0.5;
      entity2.y -= normalY * separationForce * 0.5;
    }
  }

  // Calculate knockback vector
  static calculateKnockback(fromX, fromY, toX, toY, force) {
    const dx = toX - fromX;
    const dy = toY - fromY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) {
      return { x: 0, y: 0 };
    }
    
    return {
      x: (dx / distance) * force,
      y: (dy / distance) * force
    };
  }

  // Check if point is in circle
  static pointInCircle(px, py, cx, cy, radius) {
    const dx = px - cx;
    const dy = py - cy;
    return dx * dx + dy * dy <= radius * radius;
  }

  // Check if line intersects circle
  static lineIntersectsCircle(x1, y1, x2, y2, cx, cy, radius) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const fx = x1 - cx;
    const fy = y1 - cy;
    
    const a = dx * dx + dy * dy;
    const b = 2 * (fx * dx + fy * dy);
    const c = fx * fx + fy * fy - radius * radius;
    
    const discriminant = b * b - 4 * a * c;
    return discriminant >= 0;
  }
}

// Singleton instance
let collisionSystemInstance = null;

export function getCollisionSystem() {
  if (!collisionSystemInstance) {
    collisionSystemInstance = new CollisionSystem();
  }
  return collisionSystemInstance;
}

export function resetCollisionSystem() {
  collisionSystemInstance = new CollisionSystem();
  return collisionSystemInstance;
}

export default CollisionSystem;

---

File: src\game\systems\GameLoop.js

export class GameLoop {
    constructor() {
      this.animationFrameId = null;
      this.lastTime = 0;
      this.deltaTime = 0;
      this.isRunning = false;
      this.isPaused = false; // Added isPaused state
  
      // Callbacks
      this.updateCallback = null;
      this.renderCallback = null;
  
      // Performance tracking
      this.fps = 60;
      this.frameCount = 0;
      this.fpsUpdateTimer = 0;
  
      // Timers that need cleanup
      this.activeTimers = new Set();
  
      // Bound methods to maintain context
      this.loop = this.loop.bind(this);
    }
  
    // Initialize the game loop with callbacks
    init(updateCallback, renderCallback) {
      this.updateCallback = updateCallback;
      this.renderCallback = renderCallback;
    }
  
    // Start the game loop
    start() {
      if (this.isRunning) {
        console.warn('GameLoop: Already running');
        return;
      }
  
      this.isRunning = true;
      this.isPaused = false; // Ensure not paused on start
      this.lastTime = performance.now();
      this.frameCount = 0;
      this.fpsUpdateTimer = 0;
  
      // Start the loop
      this.animationFrameId = requestAnimationFrame(this.loop);
    }
  
    // Stop the game loop
    stop() {
      if (!this.isRunning) {
        return;
      }
  
      this.isRunning = false;
  
      // Cancel animation frame
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
  
      // Clear all active timers
      this.clearAllTimers();
    }
  
    // Pause the game loop (keeps it running but doesn't update)
    pause() {
      this.isPaused = true;
    }
  
    // Resume the game loop
    resume() {
      if (this.isRunning && this.isPaused) { // Only resume if running and was paused
          this.isPaused = false;
          this.lastTime = performance.now(); // Reset time to avoid huge deltaTime
      }
    }
  
    // Main loop function
    loop(currentTime) {
      if (!this.isRunning) {
        return;
      }
  
      // Request next frame immediately
      this.animationFrameId = requestAnimationFrame(this.loop);
  
      // Calculate delta time (capped to prevent huge jumps)
      this.deltaTime = Math.min(currentTime - this.lastTime, 100); // Cap at 100ms (10 FPS)
      this.lastTime = currentTime;
  
      // Update FPS counter
      this.updateFPS(this.deltaTime);
  
      // Only update game state if not paused
      if (!this.isPaused && this.updateCallback) {
        this.updateCallback(this.deltaTime);
      }
  
      // Always render (even when paused to show pause screen, or just the static scene)
      if (this.renderCallback) {
        this.renderCallback(this.deltaTime); // Pass deltaTime in case render needs it
      }
    }
  
    // Update FPS counter
    updateFPS(deltaTime) {
      this.frameCount++;
      this.fpsUpdateTimer += deltaTime;
  
      // Update FPS every second
      if (this.fpsUpdateTimer >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / this.fpsUpdateTimer);
        this.frameCount = 0;
        this.fpsUpdateTimer = 0;
      }
    }
  
    // Get current FPS
    getFPS() {
      return this.fps;
    }
  
    // Add a timer that will be cleaned up
    addTimer(callback, delay, ...args) {
      const timerId = setTimeout(() => {
        this.activeTimers.delete(timerId);
        // Only execute callback if loop is still considered active or not explicitly stopped for this timer
        if (this.isRunning) {
          callback(...args);
        }
      }, delay);
  
      this.activeTimers.add(timerId);
      return timerId;
    }
  
    // Add an interval that will be cleaned up
    addInterval(callback, interval, ...args) {
      const intervalId = setInterval(() => {
        if (this.isRunning && !this.isPaused) { // Typically intervals respect pause
          callback(...args);
        }
      }, interval);
  
      this.activeTimers.add(intervalId);
      return intervalId;
    }
  
    // Remove a specific timer
    removeTimer(timerId) {
      if (this.activeTimers.has(timerId)) {
        clearTimeout(timerId); // Works for both setTimeout and setInterval
        clearInterval(timerId);
        this.activeTimers.delete(timerId);
      }
    }
  
    // Clear all active timers
    clearAllTimers() {
      this.activeTimers.forEach(timerId => {
        clearTimeout(timerId);
        clearInterval(timerId);
      });
      this.activeTimers.clear();
    }
  
    // Reset the game loop (for restarting)
    reset() {
      this.stop(); // Ensures cleanup
      this.deltaTime = 0;
      this.lastTime = 0;
      this.fps = 60; // Reset to default
      this.frameCount = 0;
      this.fpsUpdateTimer = 0;
      this.isPaused = false;
      // Callbacks should be re-initialized by the caller via init()
      this.updateCallback = null;
      this.renderCallback = null;
    }
  
    // Cleanup and destroy
    destroy() {
      this.stop();
      this.updateCallback = null;
      this.renderCallback = null;
    }
  }
  
  // Singleton instance
  let gameLoopInstance = null;
  
  // Factory function to get or create game loop instance
  export function getGameLoop() {
    if (!gameLoopInstance) {
      gameLoopInstance = new GameLoop();
    }
    return gameLoopInstance;
  }
  
  // Reset the singleton (for game restart)
  export function resetGameLoop() {
    if (gameLoopInstance) {
      gameLoopInstance.destroy(); // Properly clean up the old instance
    }
    gameLoopInstance = new GameLoop(); // Create a new one
    return gameLoopInstance;
  }
  
  // Helper class for managing game phases (if you decide to use it later)
  // For now, it's not directly used by the GameLoop itself.
  export class GamePhaseManager {
    // ... (keep the GamePhaseManager class as is)
    constructor() {
      this.phases = new Map();
      this.currentPhase = null;
      this.transitions = new Map();
    }
  
    // Register a game phase
    registerPhase(name, phase) {
      this.phases.set(name, phase);
    }
  
    // Register a transition between phases
    registerTransition(from, to, condition) {
      if (!this.transitions.has(from)) {
        this.transitions.set(from, []);
      }
      this.transitions.get(from).push({ to, condition });
    }
  
    // Set the current phase
    setPhase(name) {
      if (this.currentPhase && this.phases.get(this.currentPhase)?.onExit) {
        this.phases.get(this.currentPhase).onExit();
      }
  
      this.currentPhase = name;
  
      if (this.phases.get(name)?.onEnter) {
        this.phases.get(name).onEnter();
      }
    }
  
    // Update the current phase
    update(deltaTime, gameState) {
      if (!this.currentPhase) return;
  
      const phase = this.phases.get(this.currentPhase);
      if (phase?.update) {
        phase.update(deltaTime, gameState);
      }
  
      // Check for transitions
      const transitions = this.transitions.get(this.currentPhase);
      if (transitions) {
        for (const transition of transitions) {
          if (transition.condition(gameState)) {
            this.setPhase(transition.to);
            break;
          }
        }
      }
    }
  
    // Render the current phase
    render(ctx, gameState) {
      if (!this.currentPhase) return;
  
      const phase = this.phases.get(this.currentPhase);
      if (phase?.render) {
        phase.render(ctx, gameState);
      }
    }
  
    // Reset all phases
    reset() {
      if (this.currentPhase && this.phases.get(this.currentPhase)?.onExit) {
        this.phases.get(this.currentPhase).onExit();
      }
      this.currentPhase = null;
    }
  }
  
  
  export default GameLoop; // Export the class itself as default if needed elsewhere

---

File: src\game\systems\InputHandler.js



---

File: src\game\systems\WaveSystem.js



---

File: src\game\UltimatePixelGame.js

// src/game/UltimatePixelGame.js - Simplified Example
import React, { useEffect, useCallback } from 'react';
import { useGameState, useGameInput } from './hooks/useGameState'; // Assuming useGameInput is exported
import { useAbilities } from './hooks/useAbilities'; // You'll need to create this
import GameCanvas from './components/GameCanvas';
import GameUI from './components/GameUI';
import GameOverScreen from './components/GameOverScreen';
import PauseScreen from './components/PauseScreen';
import Shop from './components/Shop'; // You'll need to create this
import { getGameLoop } from './systems/GameLoop';

const UltimatePixelGame = () => {
  const {
    gameState,
    setGameState,
    abilities,
    setAbilities,
    playerRef,
    // gameLoopRef, // We get gameLoop instance directly now
    inputRef,
    mouseRef,
    restartGame,
    pauseGame,
    resumeGame,
    isLoading, // Get isLoading state
    // ... other functions from useGameState
  } = useGameState();

  const { updateAbilities: updateAbilitiesLogic, castAbility } = useAbilities(
    abilities,
    setAbilities,
    playerRef,
    gameState,
    setGameState
  );

  const gameLoop = getGameLoop(); // Get the singleton instance

  // Keyboard controls for abilities, pause, etc.
  useEffect(() => {
    const handleKeyDown = (e) => {
      // If game is over, only allow 'r' for restart
      if (!gameState.gameActive && e.key.toLowerCase() !== 'r') return;
      // If game is paused, only allow 'p' to unpause
      if (gameState.isPaused && e.key.toLowerCase() !== 'p' && gameState.gameActive) return;


      switch(e.key.toLowerCase()) {
        case ' ': // Heal
          e.preventDefault(); // Prevent space bar scrolling
          if (castAbility) castAbility('heal');
          break;
        case 'q': // Lightning
          if (castAbility) castAbility('lightning');
          break;
        case 'e': // Shield
          if (castAbility) castAbility('shield');
          break;
        // Add other ability keybinds here if needed
        // case KEY_BINDINGS.METEOR: // Assuming KEY_BINDINGS is imported
        //   if (castAbility) castAbility('meteor', mouseRef.current); // Meteor might need target
        //   break;

        case 'p': // Pause
          if (gameState.gameActive) { // Can only pause/resume an active game
            gameState.isPaused ? resumeGame() : pauseGame();
          }
          break;
        case 'r': // Restart
          if (!gameState.gameActive) { // Can only restart if game is over
            restartGame();
          }
          break;
        default:
          break;
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState.gameActive, gameState.isPaused, castAbility, pauseGame, resumeGame, restartGame, mouseRef]); // Added mouseRef for potential targeted abilities

  // Pass updateAbilitiesLogic to where the game loop's update cycle is defined (likely GameCanvas)
  // This function will be called each frame to update ability cooldowns.

  if (isLoading || !playerRef.current) { // Check isLoading as well
    return <div>Loading Game...</div>; // Changed message
  }

  return (
    <div className="ultimate-pixel-game-container">
      {/* GameUI needs playerRef, gameState, abilities, onPause */}
      <GameUI
        gameState={gameState}
        abilities={abilities}
        playerRef={playerRef}
        onPause={pauseGame}
        // onShopToggle, etc.
      />
      {/* GameCanvas needs a lot of things to manage the core game loop and rendering */}
      <GameCanvas
        gameState={gameState}
        setGameState={setGameState}
        abilities={abilities}
        playerRef={playerRef}
        inputRef={inputRef}
        mouseRef={mouseRef}
        gameLoopInstance={gameLoop} // Pass the game loop instance
        updateAbilitiesSystem={updateAbilitiesLogic} // Pass the ability update function
        castAbilitySystem={castAbility} // Pass the ability casting function
        onGameOver={() => setGameState(prev => ({ ...prev, gameActive: false }))}
      />
      {/* ... Shop, GameOverScreen, PauseScreen ... */}
      {!gameState.gameActive && <GameOverScreen gameState={gameState} onRestart={restartGame} />}
      {gameState.isPaused && <PauseScreen onResume={resumeGame} onRestart={restartGame} />}
    </div>
  );
};

export default UltimatePixelGame;

---

File: src\game\utils\gameHelpers.js



---

File: src\game\utils\mathUtils.js



---

File: src\Home.js

import React from 'react';
//import backgroundImage from './pictures/porfolio_photos/imgonline-com-ua-TextureSeamless-JCI8TaR1FBycHm.jpg';
import picture from './pictures/porfolio_photos/FaceShot2.png';

const Home = () => {
  return (
    <div className="container mt-5" style={{width: "100vw", minHeight: "100vh"}}>
      <div className="p-4 bg-tertiary shadow"> 
        <div className="bg-secondary m-3 p-5 shadow rounded">
          <div className="container"> 
            <div className="row align-items-center">
              {/* Image Column */}
              <div className="col-md-5 mb-4 mb-md-0">
                <div className="position-relative">
                  <div className="rounded-3 overflow-hidden shadow-lg">
                    <img 
                      src={picture} 
                      alt="Ty Crenshaw"
                      className="img-fluid"
                      style={{
                        width: "100%",
                        height: "auto",
                        objectFit: "cover"
                      }}
                    />
                  </div>
                  {/* Decorative element */}
                  <div 
                    className="position-absolute bg-primary" 
                    style={{
                      width: "100%",
                      height: "100%",
                      top: "10px",
                      left: "10px",
                      zIndex: -1,
                      opacity: 0.3,
                      borderRadius: "0.5rem"
                    }}
                  ></div>
                </div>
              </div>

              {/* Content Column */}
              <div className="col-md-7">
                <div className="ps-md-4">
                  <h1 className="display-4 text-accent mb-4">Ty Crenshaw</h1>
                  <h3 className="text-primary mb-4">Software Developer at LinkTrust</h3>
                  
                  <div className="mb-4">
                    <h4 className="text-accent mb-3">Professional Background</h4>
                    <p className="mb-4 text-secondary">
                      As a software developer at LinkTrust, I specialize in building online marketing solutions using .NET Framework, React, and MSSQL database. With over four years of experience, I've developed robust solutions that help businesses optimize their marketing strategies.
                    </p>
                  </div>

                  <div className="mb-4">
                    <h4 className="text-accent mb-3">Technical Expertise</h4>
                    <p className="mb-4 text-secondary">
                      My work primarily focuses on full-stack development, combining .NET Framework backend with React frontend. I'm particularly interested in artificial intelligence and constantly exploring new technologies to enhance our solutions.
                    </p>
                  </div>

                  <div className="mb-4">
                    <h4 className="text-accent mb-3">Personal Interests</h4>
                    <p className="mb-4 text-secondary">
                      Outside of coding, I enjoy gaming with my wife (Overwatch, Marvel Rivals, Beyond All Reason), taking walks, and occasionally pursuing outdoor activities like hiking and climbing. I'm always seeking new opportunities to grow both professionally and personally.
                    </p>
                  </div>

                  {/* Skills Tags */}
                  <div className="mt-4">
                    <div className="d-flex flex-wrap gap-2">
                      {['.NET', 'React', 'MSSQL', 'Full Stack', 'AI'].map((skill) => (
                        <span 
                          key={skill}
                          className="bg-primary text-tertiary px-3 py-1 rounded-pill"
                          style={{ fontSize: "0.9rem" }}
                        >
                          {skill}
                        </span>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Home;

---

File: src\index.css

/* Base styles */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Custom variables */
:root {
  --bs-background: #806743;
  --bs-primary: #BCA37F;
  --bs-secondary: #EAD7BB;
  --bs-tertiary: #FFF2D8;
  --bs-accent: #4d391d;
  --transition-speed: 0.3s;
  --box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}

/* Navigation */
.navbar-nav li a {
  color: var(--bs-tertiary) !important;
}

/* Text utilities */
.text-tertiary {
  color: var(--bs-tertiary) !important;
}

.text-accent {
  color: var(--bs-accent) !important;
}

/* Background utilities */
.bg-background { background-color: var(--bs-background) !important; }
.bg-accent { background-color: var(--bs-accent) !important; }
.bg-primary { background-color: var(--bs-primary) !important; }
.bg-secondary { background-color: var(--bs-secondary) !important; }
.bg-tertiary { background-color: var(--bs-tertiary) !important; }

/* Button styles */
.btn.btn-primary {
  color: #fff !important;
  background-color: var(--bs-primary) !important;
  border-color: var(--bs-primary) !important;
}

.btn.btn-primary:hover,
.btn.btn-primary:focus,
.btn.btn-primary:active,
.btn.btn-primary.active {
  color: #fff !important;
  background-color: var(--bs-background) !important;
  border-color: var(--bs-accent) !important;
}

.btn-light {
  --bs-btn-color: var(--bs-accent);
  --bs-btn-bg: var(--bs-tertiary);
  --bs-btn-border-color: var(--bs-tertiary);
  --bs-btn-hover-color: var(--bs-accent);
  --bs-btn-hover-bg: var(--bs-primary);
  --bs-btn-hover-border-color: var(--bs-primary);
  --bs-btn-focus-shadow-rgb: 211,212,213;
  --bs-btn-active-color: var(--bs-accent);
  --bs-btn-active-bg: var(--bs-primary);
  --bs-btn-active-border-color: var(--bs-primary);
  --bs-btn-active-shadow: var(--box-shadow);
  --bs-btn-disabled-color: var(--bs-accent);
  --bs-btn-disabled-bg: var(--bs-tertiary);
  --bs-btn-disabled-border-color: var(--bs-tertiary);
}

.btn-light:hover {
  transform: scale(1.05);
  transition: transform var(--transition-speed) ease;
}

.bg-secondary {
  background-color: var(--bs-secondary) !important;
}
.btn-secondary {
  color: #fff;
  background-color: var(--bs-secondary);
  border-color: var(--bs-secondary);
}
.btn-secondary:hover {
  color: #fff;
  background-color: #806743;
  border-color: #4d391d;
}

/* Component styles */
.moodboard {
  border: 10px solid;
  border-radius: 25px;
  padding: 20px;
  margin: auto;
}

.photo {
  border: 5px solid white;
}

/* Animations */
@keyframes gradientBg {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.animate-gradient {
  background: linear-gradient(270deg, 
    var(--bs-background), 
    var(--bs-primary), 
    var(--bs-secondary));
  background-size: 200% 200%;
  animation: gradientBg 15s ease infinite;
}

@media (max-width: 768px) {
  .container, .landing-section {
    max-width: 100%;
    width: 100%;
    box-sizing: border-box;
    padding: 1rem;
    overflow-wrap: break-word;
    word-break: break-word;
    text-align: center;
  }

  .card {
    max-width: 100%;
  }

  h1, h2, h3, h4 {
    font-size: clamp(1.2rem, 5vw, 2.5rem);
    line-height: 1.2;
  }
  
}

---

File: src\index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


---

File: src\LandingPage.js

const LandingPage = () => {
    return ( 
        <div className="container pt-5" style={{width: "100vw", minHeight: "100vh", overflow: "auto", zIndex: 20, position: "sticky"}}>
            <div className="p-5 bg-secondary shadow animate__animated animate__fadeIn animate__delay-1s"> 
                <div className="p-5 bg-background shadow" style={{color:"#FFF2D8"}}>
                    <h1 className="text-tertiary display-1 fw-bold animate__animated animate__slideInDown" 
                        style={{ letterSpacing: "0.4em", color:"#FFF2D8"}}>
                        Ty Crenshaw
                    </h1>
                    <br />
                    <br />
                    <div className="text-tertiary p-3 animate__animated animate__fadeInLeft animate__delay-2s">
                        Software Developer
                    </div>
                    <br />
                    <div className="text-tertiary p-3 animate__animated animate__fadeInLeft animate__delay-3s">
                        Always curious, always learning
                    </div>
                    <br />
                    <div className="text-tertiary p-3 animate__animated animate__fadeInLeft animate__delay-4s">
                        Nature lover, occasional adventurer
                    </div>
                    <div style={{marginTop:"20px"}}>
                        <button type="button" 
                                className="btn btn-light animate__animated animate__bounceIn animate__delay-5s"
                                onClick={() => window.location.href = "/Home"}>
                            Explore
                        </button>
                    </div>   
                </div>
            </div>
        </div>
    );
}
 
export default LandingPage;

---

File: src\Navbar.js

const Navbar = () => {
    return (
        <nav className="navbar navbar-expand-lg bg-background shadow">
            <div className="container-fluid">
                {/* Mobile hamburger button - only shows on screens smaller than lg */}
                <button 
                    className="navbar-toggler" 
                    type="button" 
                    data-bs-toggle="collapse" 
                    data-bs-target="#navbarSupportedContent" 
                    aria-controls="navbarSupportedContent" 
                    aria-expanded="false" 
                    aria-label="Toggle navigation"
                >
                    <span className="navbar-toggler-icon"></span>
                </button>

                <div className="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul className="navbar-nav me-auto mb-2 mb-lg-0">
                        <li className="nav-item">
                            <a className="nav-link active" aria-current="page" href="/Home">Home</a>
                        </li>
                        <li className="nav-item">
                            <a className="nav-link" href="/Skills">Skills</a>
                        </li>
                        <li className="nav-item">
                            <a className="nav-link" href="/Projects">Projects</a>
                        </li>
                        {/* <li className="nav-item">
                            <a className="nav-link" href="/Testimonials">Testimonials</a>
                        </li> */}
                        <li className="nav-item">
                            <a className="nav-link" href="/Contact">Contact</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    );
}

export default Navbar;

---

File: src\Projects.js

import React, { useState } from 'react';
import WorkProjects from './WorkProjects';
import SchoolProjects from './SchoolProjects';
import ForFunProjects from './ForFunProjects';
import { useNavigate } from 'react-router-dom';

const Projects = () => {
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState('work');

  return (
    <div className="container mt-5" style={{width: "100vw", minHeight: "100vh", overflow: "auto"}}>
      <h1 className="text-accent mb-4">Projects</h1>

      {/* Tab Navigation */}
      <div className="d-flex mb-4">
        <button 
          className={`btn ${activeTab === 'work' ? 'btn-primary' : 'btn-secondary'} me-2`}
          onClick={() => setActiveTab('work')}
        >
          Work Projects
        </button>
        <button 
          className={`btn ${activeTab === 'school' ? 'btn-primary' : 'btn-secondary'} me-2`}
          onClick={() => setActiveTab('school')}
        >
          School Projects
        </button>
        <button 
          className={`btn ${activeTab === 'forFun' ? 'btn-primary' : 'btn-secondary'} me-2`}
          onClick={() => setActiveTab('forFun')}
        >
          For Fun
        </button>
        <button 
          className={`btn btn-secondary`}
          onClick={() => navigate('/UltimatePixelGame')}
        >
          Ultimate Pixel Game
        </button>
      </div>

      {/* Tab Content - Using conditional rendering instead of CSS classes */}
      <div className="tab-content">
        {activeTab === 'work' && <WorkProjects />}
        {activeTab === 'school' && <SchoolProjects />}
        {activeTab === 'forFun' && <ForFunProjects />}
      </div>
    </div>
  );
};

export default Projects;

---

File: src\SchoolProjects.js

import React from 'react';
import picture from './pictures/porfolio_photos/background2.jpg';
import mainBOS from './pictures/porfolio_photos/BOSContactSheet.jpg';

const SchoolProjects = () => {
  // Creating an array of image URLs
  const images = require.context('./pictures/class_photos', false, /\.(jpg|JPG|jpeg)$/);
  const imageList = images.keys().map((image) => images(image));

  return (
    <div className="container mt-5" style={{ width: "100vw", minHeight: "100vh", overflow: "auto" }}>
      {/* Education Section */}
      <div className="p-3 bg-tertiary shadow"> 
        <div className="bg-secondary m-3 p-5 shadow">
          {/* Education Overview */}
          <div className="mb-5">
            <h2 className="text-accent mb-4">Educational Journey</h2>
            <div className="bg-tertiary p-4 rounded shadow-sm">
              <div className="d-flex align-items-center mb-4">
                <div className="bg-primary rounded-circle p-3 me-3">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className="text-tertiary">
                    <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
                    <path d="M6 12v5c3 3 9 3 12 0v-5"/>
                  </svg>
                </div>
                <div>
                  <h4 className="mb-2">Computer Science</h4>
                  <p className="mb-0 text-accent">Bachelor of Science - Completed</p>
                </div>
              </div>

              <div className="d-flex align-items-center">
                <div className="bg-primary rounded-circle p-3 me-3">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className="text-tertiary">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    <path d="M2 2l7.586 7.586"/>
                    <circle cx="11" cy="11" r="2"/>
                  </svg>
                </div>
                <div>
                  <h4 className="mb-2">Art and Design</h4>
                  <p className="mb-0 text-accent">Bachelor of Science - In Progress</p>
                </div>
              </div>
            </div>
          </div>

          {/* Photography Section */}
          <div className="mt-5">
            <h3 className="text-accent mb-4">Photography Portfolio</h3>
            <div className="moodboard p-4" style={{ 
              backgroundImage: `url(${picture})`,
              borderRadius: "1rem",
              boxShadow: "0 0.5rem 1rem rgba(0, 0, 0, 0.15)"
            }}>
              {/* Contact Sheet */}
              <div className="row mb-4">
                <div className="col-12">
                  <img 
                    className="img-fluid rounded shadow photo" 
                    src={mainBOS} 
                    alt="Contact Sheet"
                    style={{ width: "100%" }}
                  />
                </div>
              </div>

              {/* Photo Grid - Maintaining your existing grid structure */}
              <div className="row">
                {/* First Column */}
                <div className="col-md-4 d-flex flex-column">
                  {imageList.slice(0, Math.ceil(imageList.length / 3)).map((image, index) => (
                    <div key={index} className="mb-4">
                      <img 
                        className="img-fluid rounded shadow photo" 
                        src={image} 
                        alt={`Class photo ${index + 1}`}
                      />
                    </div>
                  ))}
                </div>

                {/* Second Column */}
                <div className="col-md-4 d-flex flex-column">
                  {imageList.slice(Math.ceil(imageList.length / 3), Math.ceil(2 * imageList.length / 3)).map((image, index) => (
                    <div key={index} className="mb-4">
                      <img 
                        className="img-fluid rounded shadow photo" 
                        src={image} 
                        alt={`Class photo ${Math.ceil(imageList.length / 3) + index + 1}`}
                      />
                    </div>
                  ))}
                </div>

                {/* Third Column */}
                <div className="col-md-4 d-flex flex-column">
                  {imageList.slice(Math.ceil(2 * imageList.length / 3)).map((image, index) => (
                    <div key={index} className="mb-4">
                      <img 
                        className="img-fluid rounded shadow photo" 
                        src={image} 
                        alt={`Class photo ${Math.ceil(2 * imageList.length / 3) + index + 1}`}
                      />
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SchoolProjects;

---

File: src\Skills.js

import React, { useState, useEffect } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

const DraggableAccordionItem = ({ skill, isExpanded, onToggle }) => {
    const {
      attributes,
      listeners,
      setNodeRef,
      transform,
      transition,
      isDragging
    } = useSortable({ id: skill.title });
  
    const style = {
      transform: CSS.Transform.toString(transform),
      transition,
      opacity: isDragging ? 0.5 : 1,
      zIndex: isDragging ? 1000 : 1
    };
  
    return (
      <div
        ref={setNodeRef}
        className="mt-5 card w-100 shadow"
        style={style}
      >
        <div className="card-header bg-primary text-tertiary">
          <div className="d-flex justify-content-between align-items-center">
            <div 
              {...attributes} 
              {...listeners}
              className="me-3" 
              style={{ 
                cursor: 'grab',
                fontSize: '20px',
                userSelect: 'none'
              }}
            >
              
            </div>
  
            <h5 className="mb-0 flex-grow-1">{skill.title}</h5>
  
            <button
              onClick={() => onToggle(skill.title)}
              className="btn btn-link text-tertiary ms-3"
              style={{ 
                textDecoration: 'none',
                fontSize: '20px',
                padding: '0 10px',
                cursor: 'pointer'
              }}
            >
              {isExpanded ? '' : ''}
            </button>
          </div>
        </div>
  
        <div 
          className={`card-footer bg-tertiary ${isExpanded ? 'd-block' : 'd-none'}`}
        >
          <blockquote className="blockquote mb-0">
            <p>{skill.content}</p>
          </blockquote>
        </div>
      </div>
    );
  };
  
  const DraggableAccordionStack = () => {
    const [expandedCards, setExpandedCards] = useState(new Set());
    const [skillList, setSkillList] = useState([
      {
        title: 'What are the main programming languages, tools, and frameworks that you use in your work?',
        content: 'I am a .NET developer who uses C# as my primary programming language. I use the MVC pattern to create web applications that separate the presentation, business logic, and data access layers. I use SQL Server Management Studio (SSMS) as my database management tool, and SQL as my query language to interact with the data stored in the back end of my applications.'
      },
      {
        title: 'What are the main types of software applications or systems that you develop or maintain?',
        content: 'I develop and maintain in-house projects that offer affiliate marketing services to other businesses. Affiliate marketing is a type of online marketing where affiliates earn commissions for referring customers or leads to a business. My projects provide tools for tracking, reporting, analytics, lead generation, and more to help my clients improve their marketing strategies and results.'
      },
      {
        title: 'How do you collaborate with other developers, designers, testers, or stakeholders in your projects?',
        content: 'I use Jira as my project management tool to keep track of tasks, features, bugs, and progress. I follow the agile methodology to deliver software in short and iterative cycles. I have daily stand-up meetings with my team to share what I have done, what I plan to do, and what challenges I face. I also have weekly sizing meetings with my team and stakeholders to estimate the effort and complexity of future features, and prioritize them according to the client\'s needs and expectations.'
      },
      {
        title: 'What are some of the most challenging or interesting projects that you have worked on?',
        content: 'One of my most challenging projects was the partner sign-up project. The goal was to create a customizable sign-up page for each client that allows them to collect different information from their affiliates based on their requirements. Some of the challenges that I faced were handling a lot of variation and validation for each field, ensuring security and privacy of the data, and integrating with other systems or services.'
      },
      {
        title: 'How do you keep your skills and knowledge up to date?',
        content: 'I am always eager to learn new skills and technologies that are relevant to my work. Some of the sources or resources that I use for learning new technologies or best practices are online courses from Pluralsight, Podcasts, and videos from Youtube. Some of the topics or areas that I am interested in or curious about are AI, machine learning, cloud computing, etc.'
      }
    ]);
  
    // Initialize all cards as expanded
    useEffect(() => {
      setExpandedCards(new Set(skillList.map(skill => skill.title)));
    }, []);
  
    const sensors = useSensors(
      useSensor(PointerSensor, {
        activationConstraint: {
          distance: 8,
        },
      }),
      useSensor(KeyboardSensor, {
        coordinateGetter: sortableKeyboardCoordinates,
      })
    );
  
    const handleDragEnd = (event) => {
      const { active, over } = event;
      
      if (active.id !== over.id) {
        setSkillList((items) => {
          const oldIndex = items.findIndex((item) => item.title === active.id);
          const newIndex = items.findIndex((item) => item.title === over.id);
          return arrayMove(items, oldIndex, newIndex);
        });
      }
    };
  
    const toggleCard = (cardId) => {
      setExpandedCards(prev => {
        const newExpanded = new Set(prev);
        if (newExpanded.has(cardId)) {
          newExpanded.delete(cardId);
        } else {
          newExpanded.add(cardId);
        }
        return newExpanded;
      });
    };
  
    return (
      <div className="container mt-5" style={{width: "100vw", minHeight: "100vh", overflow: "auto"}}>
        <h1 className="text-accent">Skills</h1>
        <div className="d-flex flex-column align-items-center">
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={skillList.map(skill => skill.title)}
              strategy={verticalListSortingStrategy}
            >
              {skillList.map((skill) => (
                <DraggableAccordionItem
                  key={skill.title}
                  skill={skill}
                  isExpanded={expandedCards.has(skill.title)}
                  onToggle={toggleCard}
                />
              ))}
            </SortableContext>
          </DndContext>
        </div>
      </div>
    );
  };

export default DraggableAccordionStack;

---

File: src\Testimonials.js

const Testimonials = () => {
    return ( 
    <div className="container mt-5" style={{width: "100vw", minHeight: "100vh", overflow: "auto"}}>
        <h2>Testimonials</h2>
    </div> );
}
 
export default Testimonials;

---

File: src\UltimatePixelGame.js

import React, { useState, useEffect, useRef, useCallback } from 'react';

const UltimatePixelGame = () => {
  // Initial game state - moved to a function for reusability
  const getInitialGameState = () => ({
    player: { 
      x: 400, y: 300, 
      health: 100, maxHealth: 100,
      mana: 100, maxMana: 100,
      level: 1, experience: 0, experienceToNext: 100,
      speed: 3, damage: 25,
      critChance: 0.1, critMultiplier: 2,
      coins: 0
    },
    enemies: [],
    powerups: [],
    projectiles: [],
    particles: [],
    floatingTexts: [],
    explosions: [],
    wave: 1,
    waveTimer: 0,
    enemiesKilled: 0,
    gameActive: true,
    isPaused: false,
    score: 0,
    gameTime: 0,
    combo: 0,
    comboTimer: 0,
    shopOpen: false,
    achievements: []
  });

  // Initial abilities state - moved to function for reusability
  const getInitialAbilities = () => ({
    fireball: { cooldown: 0, maxCooldown: 800, damage: 30, manaCost: 15, level: 1 },
    heal: { cooldown: 0, maxCooldown: 3000, healAmount: 40, manaCost: 25, level: 1 },
    shield: { cooldown: 0, maxCooldown: 8000, duration: 0, maxDuration: 3000, manaCost: 30, level: 1 },
    lightning: { cooldown: 0, maxCooldown: 2000, damage: 60, manaCost: 40, level: 1 },
    meteor: { cooldown: 0, maxCooldown: 5000, damage: 100, manaCost: 60, level: 1 },
    freeze: { cooldown: 0, maxCooldown: 4000, duration: 2000, manaCost: 35, level: 1 }
  });

  // Core game state
  const [gameState, setGameState] = useState(getInitialGameState);

  // Player abilities with proper state management
  const [abilities, setAbilities] = useState(getInitialAbilities);

  // Shop items
  const shopItems = [
    { id: 'health_upgrade', name: 'Health Boost', description: '+20 Max Health', price: 100, type: 'permanent' },
    { id: 'mana_upgrade', name: 'Mana Boost', description: '+15 Max Mana', price: 80, type: 'permanent' },
    { id: 'speed_upgrade', name: 'Speed Boost', description: '+0.5 Movement Speed', price: 120, type: 'permanent' },
    { id: 'crit_upgrade', name: 'Critical Strike', description: '+5% Crit Chance', price: 150, type: 'permanent' },
    { id: 'fireball_upgrade', name: 'Fireball Mastery', description: '+10 Damage, -200ms Cooldown', price: 200, type: 'ability' },
    { id: 'heal_upgrade', name: 'Healing Mastery', description: '+15 Healing, -500ms Cooldown', price: 180, type: 'ability' },
    { id: 'lightning_upgrade', name: 'Lightning Mastery', description: '+20 Damage, Chain 2 Enemies', price: 250, type: 'ability' },
    { id: 'meteor_unlock', name: 'Meteor Spell', description: 'Unlock devastating area spell', price: 300, type: 'unlock' }
  ];

  // Achievements system
  const achievementList = [
    { id: 'first_kill', name: 'First Blood', description: 'Kill your first enemy', condition: (state) => state.enemiesKilled >= 1 },
    { id: 'wave_5', name: 'Survivor', description: 'Reach wave 5', condition: (state) => state.wave >= 5 },
    { id: 'level_5', name: 'Experienced', description: 'Reach level 5', condition: (state) => state.player.level >= 5 },
    { id: 'combo_10', name: 'Combo Master', description: 'Get a 10x combo', condition: (state) => state.combo >= 10 },
    { id: 'rich', name: 'Wealthy Mage', description: 'Collect 500 coins', condition: (state) => state.player.coins >= 500 },
    { id: 'wave_10', name: 'Veteran', description: 'Reach wave 10', condition: (state) => state.wave >= 10 },
    { id: 'perfectionist', name: 'Untouchable', description: 'Complete a wave without taking damage', condition: (state) => false }, // Custom logic needed
    { id: 'speed_demon', name: 'Speed Demon', description: 'Kill 20 enemies in 30 seconds', condition: (state) => false } // Custom logic needed
  ];

  // Enhanced enemy types with better balance
  const enemyTypes = {
    slime: { 
      health: 40, speed: 1.2, damage: 15, color: '#44ff44', points: 100, size: 20,
      spawnWeight: 0.4, minWave: 1
    },
    orc: { 
      health: 80, speed: 1.8, damage: 25, color: '#ff4444', points: 150, size: 25,
      spawnWeight: 0.3, minWave: 2
    },
    golem: { 
      health: 150, speed: 0.8, damage: 40, color: '#888888', points: 250, size: 35,
      spawnWeight: 0.2, minWave: 3
    },
    demon: { 
      health: 100, speed: 2.5, damage: 35, color: '#ff00ff', points: 300, size: 30,
      spawnWeight: 0.15, minWave: 4
    },
    boss: { 
      health: 400, speed: 1.5, damage: 50, color: '#8800ff', points: 1000, size: 50,
      spawnWeight: 0.05, minWave: 5
    }
  };

  // Powerup types
  const powerupTypes = {
    health: { color: '#ff3333', effect: 'heal', value: 50, duration: 0 },
    mana: { color: '#3333ff', effect: 'mana', value: 40, duration: 0 },
    experience: { color: '#ffff33', effect: 'experience', value: 50, duration: 0 },
    speed: { color: '#33ff33', effect: 'tempSpeed', value: 1.5, duration: 8000 },
    damage: { color: '#ff8833', effect: 'tempDamage', value: 2, duration: 10000 }
  };

  const canvasRef = useRef(null);
  const gameLoopRef = useRef(null);
  const keysRef = useRef({ w: false, a: false, s: false, d: false });
  const mouseRef = useRef({ x: 400, y: 300, down: false });
  const tempEffectsRef = useRef({ speed: 0, damage: 0, speedMultiplier: 1, damageMultiplier: 1 });
  const spawnTimeoutRef = useRef(null); // Add ref to track spawn timeout

  // Initialize game
  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      canvas.width = 800;
      canvas.height = 600;
    }
    
    // Add initial enemies
    spawnWaveEnemies(3);
    
    startGameLoop();
    
    return () => {
      if (gameLoopRef.current) {
        cancelAnimationFrame(gameLoopRef.current);
      }
      // Clear any pending spawn timeouts
      if (spawnTimeoutRef.current) {
        clearTimeout(spawnTimeoutRef.current);
      }
    };
  }, []);

  // Keyboard controls
  useEffect(() => {
    const handleKeyDown = (e) => {
      switch(e.key.toLowerCase()) {
        case 'w': keysRef.current.w = true; break;
        case 'a': keysRef.current.a = true; break;
        case 's': keysRef.current.s = true; break;
        case 'd': keysRef.current.d = true; break;
        case ' ': 
          e.preventDefault(); 
          castHeal(); 
          break;
        case 'q': castLightning(); break;
        case 'e': castShield(); break;
        case 'p': togglePause(); break;
        case 'r': if (!gameState.gameActive) restartGame(); break;
      }
    };

    const handleKeyUp = (e) => {
      switch(e.key.toLowerCase()) {
        case 'w': keysRef.current.w = false; break;
        case 'a': keysRef.current.a = false; break;
        case 's': keysRef.current.s = false; break;
        case 'd': keysRef.current.d = false; break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Mouse controls
  const handleMouseMove = (e) => {
    const rect = canvasRef.current?.getBoundingClientRect();
    if (rect) {
      mouseRef.current.x = e.clientX - rect.left;
      mouseRef.current.y = e.clientY - rect.top;
    }
  };

  const handleMouseDown = (e) => {
    mouseRef.current.down = true;
    castFireball(mouseRef.current.x, mouseRef.current.y);
  };

  const handleMouseUp = () => {
    mouseRef.current.down = false;
  };

  // Game loop
  const gameLoop = useCallback(() => {
    // Only update abilities when game is paused or over, but stop everything else
    if (!gameState.gameActive) {
      updateAbilities(16); // Keep updating cooldowns for UI
      gameLoopRef.current = requestAnimationFrame(gameLoop);
      return;
    }

    if (gameState.isPaused) {
      gameLoopRef.current = requestAnimationFrame(gameLoop);
      return;
    }

    setGameState(prevState => {
      const newState = { ...prevState };
      const deltaTime = 16; // Assume 60fps

      // Update game time
      newState.gameTime += deltaTime;

      // Update player movement
      updatePlayerMovement(newState, deltaTime);

      // Update wave system
      updateWaveSystem(newState, deltaTime);

      // Update all game objects
      updateEnemies(newState, deltaTime);
      updateProjectiles(newState, deltaTime);
      updateParticles(newState, deltaTime);
      updateFloatingTexts(newState, deltaTime);
      updateExplosions(newState, deltaTime);
      updateTempEffects(deltaTime);

      // Check all collisions
      checkCollisions(newState);

      // Update abilities and effects
      updatePlayerStats(newState);

      // Spawn powerups occasionally
      if (Math.random() < 0.0008) {
        spawnPowerup(newState);
      }

      // Auto mana regeneration
      if (newState.player.mana < newState.player.maxMana) {
        newState.player.mana = Math.min(newState.player.maxMana, newState.player.mana + 0.1);
      }

      return newState;
    });

    // Update abilities separately to avoid state issues
    updateAbilities(16);

    gameLoopRef.current = requestAnimationFrame(gameLoop);
  }, [gameState.gameActive, gameState.isPaused]);

  const startGameLoop = () => {
    if (gameLoopRef.current) {
      cancelAnimationFrame(gameLoopRef.current);
    }
    gameLoopRef.current = requestAnimationFrame(gameLoop);
  };

  const updatePlayerMovement = (state, deltaTime) => {
    const speed = state.player.speed * tempEffectsRef.current.speedMultiplier;
    let dx = 0, dy = 0;

    if (keysRef.current.w) dy -= speed;
    if (keysRef.current.s) dy += speed;
    if (keysRef.current.a) dx -= speed;
    if (keysRef.current.d) dx += speed;

    // Normalize diagonal movement
    if (dx !== 0 && dy !== 0) {
      dx *= 0.707;
      dy *= 0.707;
    }

    // Update position with bounds checking
    state.player.x = Math.max(20, Math.min(780, state.player.x + dx));
    state.player.y = Math.max(20, Math.min(580, state.player.y + dy));
  };

  const updateWaveSystem = (state, deltaTime) => {
    state.waveTimer += deltaTime;
    
    // Update combo timer
    if (state.combo > 0) {
      state.comboTimer -= deltaTime;
      if (state.comboTimer <= 0) {
        state.combo = 0;
      }
    }
    
    // New wave every 20 seconds or when all enemies are dead
    if (state.waveTimer > 20000 || (state.enemies.length === 0 && state.waveTimer > 5000)) {
      state.wave += 1;
      state.waveTimer = 0;
      
      const enemyCount = Math.min(3 + Math.floor(state.wave / 2), 12);
      spawnWaveEnemies(enemyCount);
      
      addFloatingText(state, 400, 100, `Wave ${state.wave}!`, '#ffff00', 2000);
      
      // Check wave achievements
      checkAchievements(state);
    }
  };

  const spawnWaveEnemies = (count) => {
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        setGameState(prevState => {
          // Check if game is still active before spawning
          if (!prevState.gameActive) return prevState;
          
          const newState = { ...prevState };
          spawnEnemy(newState);
          return newState;
        });
      }, i * 500);
    }
  };

  const spawnEnemy = (state) => {
    // Filter enemy types based on current wave
    const availableTypes = Object.entries(enemyTypes).filter(
      ([_, type]) => state.wave >= type.minWave
    );

    // Weighted random selection
    const totalWeight = availableTypes.reduce((sum, [_, type]) => sum + type.spawnWeight, 0);
    let random = Math.random() * totalWeight;
    let selectedType = 'slime';

    for (const [typeName, type] of availableTypes) {
      random -= type.spawnWeight;
      if (random <= 0) {
        selectedType = typeName;
        break;
      }
    }

    // Spawn position (from edges)
    const side = Math.floor(Math.random() * 4);
    let x, y;
    
    switch(side) {
      case 0: x = Math.random() * 800; y = -30; break;
      case 1: x = 830; y = Math.random() * 600; break;
      case 2: x = Math.random() * 800; y = 630; break;
      case 3: x = -30; y = Math.random() * 600; break;
    }

    const enemyData = enemyTypes[selectedType];
    const enemy = {
      id: Date.now() + Math.random(),
      x, y, type: selectedType,
      health: enemyData.health + Math.floor(state.wave * 5), // Scale with wave
      maxHealth: enemyData.health + Math.floor(state.wave * 5),
      speed: enemyData.speed + (state.wave * 0.1),
      damage: enemyData.damage + Math.floor(state.wave * 2),
      ...enemyData,
      lastDamageTime: 0
    };

    state.enemies.push(enemy);
  };

  const updateEnemies = (state, deltaTime) => {
    state.enemies.forEach(enemy => {
      // Handle freeze effect
      if (enemy.frozen > 0) {
        enemy.frozen -= deltaTime;
        if (enemy.frozen <= 0) {
          enemy.speed = enemy.originalSpeed || enemy.speed;
        }
      }
      
      if (enemy.speed > 0) {
        const dx = state.player.x - enemy.x;
        const dy = state.player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 1) {
          const normalizedDx = dx / distance;
          const normalizedDy = dy / distance;
          
          enemy.x += normalizedDx * enemy.speed;
          enemy.y += normalizedDy * enemy.speed;
        }
      }

      // Update damage flash
      if (enemy.lastDamageTime > 0) {
        enemy.lastDamageTime -= deltaTime;
      }
    });
  };

  const updateProjectiles = (state, deltaTime) => {
    state.projectiles = state.projectiles.filter(projectile => {
      projectile.x += projectile.vx;
      projectile.y += projectile.vy;
      projectile.life -= deltaTime;
      
      return projectile.x > -50 && projectile.x < 850 && 
             projectile.y > -50 && projectile.y < 650 &&
             projectile.life > 0;
    });
  };

  const updateParticles = (state, deltaTime) => {
    state.particles = state.particles.filter(particle => {
      particle.life -= deltaTime / 1000;
      particle.x += particle.vx;
      particle.y += particle.vy;
      particle.vy += 0.1; // Gravity
      particle.vx *= 0.99; // Air resistance
      
      return particle.life > 0;
    });
  };

  const updateFloatingTexts = (state, deltaTime) => {
    state.floatingTexts = state.floatingTexts.filter(text => {
      text.life -= deltaTime;
      text.y -= 1;
      text.alpha = text.life / text.maxLife;
      return text.life > 0;
    });
  };

  const updateTempEffects = (deltaTime) => {
    const effects = tempEffectsRef.current;
    
    if (effects.speed > 0) {
      effects.speed -= deltaTime;
      if (effects.speed <= 0) {
        effects.speedMultiplier = 1;
      }
    }
    
    if (effects.damage > 0) {
      effects.damage -= deltaTime;
      if (effects.damage <= 0) {
        effects.damageMultiplier = 1;
      }
    }
  };

  const updateAbilities = (deltaTime) => {
    setAbilities(prev => {
      const newAbilities = { ...prev };
      
      Object.keys(newAbilities).forEach(key => {
        if (newAbilities[key].cooldown > 0) {
          newAbilities[key].cooldown = Math.max(0, newAbilities[key].cooldown - deltaTime);
        }
        if (newAbilities[key].duration > 0) {
          newAbilities[key].duration = Math.max(0, newAbilities[key].duration - deltaTime);
        }
      });
      
      return newAbilities;
    });
  };

  const updatePlayerStats = (state) => {
    // Check for level up
    if (state.player.experience >= state.player.experienceToNext) {
      state.player.level += 1;
      state.player.experience -= state.player.experienceToNext;
      state.player.experienceToNext = state.player.level * 100;
      
      // Level up bonuses
      state.player.maxHealth += 10;
      state.player.health = state.player.maxHealth;
      state.player.maxMana += 5;
      state.player.mana = state.player.maxMana;
      state.player.damage += 5;
      
      addFloatingText(state, state.player.x, state.player.y - 30, 'LEVEL UP!', '#ffff00', 2000);
      createParticles(state, state.player.x, state.player.y, '#ffff00', 15);
    }
  };

  const checkCollisions = (state) => {
    // Player vs enemies
    state.enemies.forEach((enemy, enemyIndex) => {
      const dx = state.player.x - enemy.x;
      const dy = state.player.y - enemy.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const minDistance = 25 + enemy.size / 2;
      
      if (distance < minDistance) {
        if (abilities.shield.duration > 0) {
          // Shield blocks damage - just add visual feedback
          addFloatingText(state, state.player.x, state.player.y - 20, 'BLOCKED!', '#00ffff', 800);
          createParticles(state, state.player.x, state.player.y, '#00ffff', 6);
          
          // Knockback enemy instead
          const knockbackForce = 15;
          const normalizedDx = -dx / distance;
          const normalizedDy = -dy / distance;
          enemy.x += normalizedDx * knockbackForce;
          enemy.y += normalizedDy * knockbackForce;
        } else {
          // Take damage
          state.player.health = Math.max(0, state.player.health - enemy.damage);
          addFloatingText(state, state.player.x, state.player.y - 20, `-${enemy.damage}`, '#ff0000', 1000);
          createParticles(state, state.player.x, state.player.y, '#ff0000', 8);
          
          // Knockback player
          const knockbackForce = 20;
          const normalizedDx = dx / distance;
          const normalizedDy = dy / distance;
          state.player.x += normalizedDx * knockbackForce;
          state.player.y += normalizedDy * knockbackForce;
          
          if (state.player.health <= 0) {
            state.gameActive = false;
          }
        }
      }
    });

    // Projectiles vs enemies
    state.projectiles.forEach((projectile, pIndex) => {
      state.enemies.forEach((enemy, eIndex) => {
        const dx = projectile.x - enemy.x;
        const dy = projectile.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < enemy.size / 2 + 5) {
          let damage = Math.floor(projectile.damage * tempEffectsRef.current.damageMultiplier);
          
          // Check for critical hit
          const isCrit = Math.random() < state.player.critChance;
          if (isCrit) {
            damage = Math.floor(damage * state.player.critMultiplier);
            addFloatingText(state, enemy.x, enemy.y - 30, `CRIT! -${damage}`, '#ffff00', 1000);
            createParticles(state, enemy.x, enemy.y, '#ffff00', 8);
          } else {
            addFloatingText(state, enemy.x, enemy.y - 20, `-${damage}`, '#ffffff', 800);
          }
          
          enemy.health -= damage;
          enemy.lastDamageTime = 200;
          
          createParticles(state, enemy.x, enemy.y, projectile.color, 6);
          
          // Handle meteor explosion
          if (projectile.type === 'meteor') {
            createExplosion(state, projectile.x, projectile.y, 80, damage * 0.7);
          }
          
          // Remove projectile
          state.projectiles.splice(pIndex, 1);
          
          if (enemy.health <= 0) {
            // Enemy defeated
            const points = enemy.points * (1 + state.combo * 0.1); // Combo bonus
            const coins = Math.floor(enemy.points / 20) + Math.floor(Math.random() * 3);
            
            state.score += Math.floor(points);
            state.player.experience += Math.floor(points / 10);
            state.player.coins += coins;
            state.enemiesKilled += 1;
            
            // Update combo
            state.combo += 1;
            state.comboTimer = 3000; // 3 seconds to maintain combo
            
            addFloatingText(state, enemy.x, enemy.y, `+${Math.floor(points)}`, '#00ff00', 1000);
            addFloatingText(state, enemy.x, enemy.y + 15, `+${coins} coins`, '#ffd700', 800);
            if (state.combo > 1) {
              addFloatingText(state, enemy.x, enemy.y - 35, `${state.combo}x COMBO!`, '#ff8800', 1200);
            }
            
            createParticles(state, enemy.x, enemy.y, enemy.color, 12);
            
            state.enemies.splice(eIndex, 1);
            
            // Check achievements
            checkAchievements(state);
          }
        }
      });
    });

    // Player vs powerups
    state.powerups.forEach((powerup, index) => {
      const dx = state.player.x - powerup.x;
      const dy = state.player.y - powerup.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 30) {
        applyPowerup(state, powerup);
        state.powerups.splice(index, 1);
        createParticles(state, powerup.x, powerup.y, powerup.color, 8);
      }
    });
  };

  const spawnPowerup = (state) => {
    const types = Object.keys(powerupTypes);
    const type = types[Math.floor(Math.random() * types.length)];
    
    const powerup = {
      id: Date.now() + Math.random(),
      x: Math.random() * 750 + 25,
      y: Math.random() * 550 + 25,
      type,
      ...powerupTypes[type],
      pulsePhase: 0
    };

    state.powerups.push(powerup);
  };

  const applyPowerup = (state, powerup) => {
    const effects = tempEffectsRef.current;
    
    switch(powerup.effect) {
      case 'heal':
        state.player.health = Math.min(state.player.maxHealth, state.player.health + powerup.value);
        addFloatingText(state, state.player.x, state.player.y - 20, `+${powerup.value} HP`, '#00ff00', 1000);
        break;
      case 'mana':
        state.player.mana = Math.min(state.player.maxMana, state.player.mana + powerup.value);
        addFloatingText(state, state.player.x, state.player.y - 20, `+${powerup.value} MP`, '#0099ff', 1000);
        break;
      case 'experience':
        state.player.experience += powerup.value;
        addFloatingText(state, state.player.x, state.player.y - 20, `+${powerup.value} XP`, '#ffff00', 1000);
        break;
      case 'tempSpeed':
        effects.speed = powerup.duration;
        effects.speedMultiplier = powerup.value;
        addFloatingText(state, state.player.x, state.player.y - 20, 'SPEED UP!', '#00ff00', 1000);
        break;
      case 'tempDamage':
        effects.damage = powerup.duration;
        effects.damageMultiplier = powerup.value;
        addFloatingText(state, state.player.x, state.player.y - 20, 'DAMAGE UP!', '#ff8800', 1000);
        break;
    }
  };

  const createExplosion = (state, x, y, radius, damage) => {
    state.explosions.push({
      x, y, radius,
      life: 500,
      maxLife: 500
    });
    
    // Damage enemies in explosion radius
    state.enemies.forEach(enemy => {
      const dx = enemy.x - x;
      const dy = enemy.y - y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < radius) {
        const explosionDamage = Math.floor(damage * (1 - distance / radius));
        enemy.health -= explosionDamage;
        enemy.lastDamageTime = 200;
        
        addFloatingText(state, enemy.x, enemy.y - 20, `-${explosionDamage}`, '#ff8800', 800);
        createParticles(state, enemy.x, enemy.y, '#ff4400', 6);
        
        if (enemy.health <= 0) {
          const points = enemy.points * (1 + state.combo * 0.1);
          const coins = Math.floor(enemy.points / 20) + Math.floor(Math.random() * 3);
          
          state.score += Math.floor(points);
          state.player.experience += Math.floor(points / 10);
          state.player.coins += coins;
          state.enemiesKilled += 1;
          state.combo += 1;
          state.comboTimer = 3000;
          
          addFloatingText(state, enemy.x, enemy.y, `+${Math.floor(points)}`, '#00ff00', 1000);
          
          const enemyIndex = state.enemies.indexOf(enemy);
          if (enemyIndex > -1) {
            state.enemies.splice(enemyIndex, 1);
          }
        }
      }
    });
    
    createParticles(state, x, y, '#ff4400', 20);
  };

  const updateExplosions = (state, deltaTime) => {
    state.explosions = state.explosions.filter(explosion => {
      explosion.life -= deltaTime;
      return explosion.life > 0;
    });
  };

  const checkAchievements = (state) => {
    achievementList.forEach(achievement => {
      if (!state.achievements.includes(achievement.id) && achievement.condition(state)) {
        state.achievements.push(achievement.id);
        addFloatingText(state, 400, 200, `Achievement: ${achievement.name}!`, '#ffd700', 3000);
        createParticles(state, 400, 200, '#ffd700', 15);
        
        // Achievement rewards
        state.player.coins += 50;
        state.player.experience += 100;
      }
    });
  };

  const purchaseItem = (itemId) => {
    const item = shopItems.find(i => i.id === itemId);
    if (!item || gameState.player.coins < item.price) return;

    setGameState(prevState => {
      const newState = { ...prevState };
      newState.player.coins -= item.price;
      
      switch(item.id) {
        case 'health_upgrade':
          newState.player.maxHealth += 20;
          newState.player.health = newState.player.maxHealth;
          break;
        case 'mana_upgrade':
          newState.player.maxMana += 15;
          newState.player.mana = newState.player.maxMana;
          break;
        case 'speed_upgrade':
          newState.player.speed += 0.5;
          break;
        case 'crit_upgrade':
          newState.player.critChance += 0.05;
          break;
      }
      
      addFloatingText(newState, newState.player.x, newState.player.y - 30, `Purchased: ${item.name}!`, '#00ff00', 2000);
      
      return newState;
    });

    // Handle ability upgrades
    if (item.type === 'ability') {
      setAbilities(prev => {
        const newAbilities = { ...prev };
        
        switch(item.id) {
          case 'fireball_upgrade':
            newAbilities.fireball.damage += 10;
            newAbilities.fireball.maxCooldown = Math.max(400, newAbilities.fireball.maxCooldown - 200);
            break;
          case 'heal_upgrade':
            newAbilities.heal.healAmount += 15;
            newAbilities.heal.maxCooldown = Math.max(1500, newAbilities.heal.maxCooldown - 500);
            break;
          case 'lightning_upgrade':
            newAbilities.lightning.damage += 20;
            break;
        }
        
        return newAbilities;
      });
    }
  };

  const addFloatingText = (state, x, y, text, color, duration) => {
    state.floatingTexts.push({
      x, y, text, color,
      life: duration,
      maxLife: duration,
      alpha: 1
    });
  };

  // Spell casting functions
  const castFireball = (targetX, targetY) => {
    if (abilities.fireball.cooldown > 0 || gameState.player.mana < abilities.fireball.manaCost || !gameState.gameActive) return;

    const dx = targetX - gameState.player.x;
    const dy = targetY - gameState.player.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const speed = 12;

    setGameState(prev => ({
      ...prev,
      player: { ...prev.player, mana: prev.player.mana - abilities.fireball.manaCost },
      projectiles: [...prev.projectiles, {
        x: prev.player.x,
        y: prev.player.y,
        vx: (dx / distance) * speed,
        vy: (dy / distance) * speed,
        damage: abilities.fireball.damage,
        color: '#ff4400',
        life: 2000
      }]
    }));

    setAbilities(prev => ({
      ...prev,
      fireball: { ...prev.fireball, cooldown: prev.fireball.maxCooldown }
    }));
  };

  const castHeal = () => {
    if (abilities.heal.cooldown > 0 || gameState.player.mana < abilities.heal.manaCost || !gameState.gameActive) return;

    setGameState(prev => {
      const healAmount = Math.min(abilities.heal.healAmount, prev.player.maxHealth - prev.player.health);
      const newState = {
        ...prev,
        player: {
          ...prev.player,
          health: Math.min(prev.player.maxHealth, prev.player.health + abilities.heal.healAmount),
          mana: prev.player.mana - abilities.heal.manaCost
        }
      };
      
      addFloatingText(newState, prev.player.x, prev.player.y - 20, `+${healAmount}`, '#00ff00', 1000);
      createParticles(newState, prev.player.x, prev.player.y, '#00ff00', 10);
      
      return newState;
    });

    setAbilities(prev => ({
      ...prev,
      heal: { ...prev.heal, cooldown: prev.heal.maxCooldown }
    }));
  };

  const castShield = () => {
    if (abilities.shield.cooldown > 0 || gameState.player.mana < abilities.shield.manaCost || !gameState.gameActive) return;

    setGameState(prev => ({
      ...prev,
      player: { ...prev.player, mana: prev.player.mana - abilities.shield.manaCost }
    }));

    setAbilities(prev => ({
      ...prev,
      shield: { 
        ...prev.shield, 
        cooldown: prev.shield.maxCooldown,
        duration: prev.shield.maxDuration
      }
    }));
  };

  const castLightning = () => {
    if (abilities.lightning.cooldown > 0 || gameState.player.mana < abilities.lightning.manaCost || !gameState.gameActive) return;

    setGameState(prev => {
      const newState = { ...prev };
      newState.player.mana -= abilities.lightning.manaCost;
      
      // Find closest enemy
      let closestEnemy = null;
      let closestDistance = Infinity;
      
      newState.enemies.forEach(enemy => {
        const dx = enemy.x - newState.player.x;
        const dy = enemy.y - newState.player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance && distance < 200) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      if (closestEnemy) {
        const damage = Math.floor(abilities.lightning.damage * tempEffectsRef.current.damageMultiplier);
        closestEnemy.health -= damage;
        closestEnemy.lastDamageTime = 200;
        
        addFloatingText(newState, closestEnemy.x, closestEnemy.y - 20, `-${damage}`, '#ffff00', 800);
        createParticles(newState, closestEnemy.x, closestEnemy.y, '#ffff00', 12);
        
        if (closestEnemy.health <= 0) {
          newState.score += closestEnemy.points;
          newState.player.experience += Math.floor(closestEnemy.points / 10);
          newState.enemiesKilled += 1;
          
          const enemyIndex = newState.enemies.indexOf(closestEnemy);
          if (enemyIndex > -1) {
            newState.enemies.splice(enemyIndex, 1);
          }
        }
      }
      
      return newState;
    });

    setAbilities(prev => ({
      ...prev,
      lightning: { ...prev.lightning, cooldown: prev.lightning.maxCooldown }
    }));
  };

  const createParticles = (state, x, y, color, count = 8) => {
    for (let i = 0; i < count; i++) {
      state.particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6 - 2,
        color,
        life: 1 + Math.random()
      });
    }
  };

  const castMeteor = (targetX, targetY) => {
    if (abilities.meteor.cooldown > 0 || gameState.player.mana < abilities.meteor.manaCost || !gameState.gameActive) return;

    // Create meteor warning circle first
    setGameState(prev => {
      const newState = { ...prev };
      newState.player.mana -= abilities.meteor.manaCost;
      
      // Add visual warning
      addFloatingText(newState, targetX, targetY - 50, 'INCOMING!', '#ff4400', 1500);
      createParticles(newState, targetX, targetY, '#ff4400', 10);
      
      // Meteor lands after 1 second
      setTimeout(() => {
        setGameState(prevState => {
          if (!prevState.gameActive) return prevState; // Check if game is still active
          
          const meteorState = { ...prevState };
          meteorState.projectiles.push({
            x: targetX,
            y: targetY,
            vx: 0, vy: 0,
            damage: abilities.meteor.damage,
            color: '#ff4400',
            life: 100,
            type: 'meteor'
          });
          return meteorState;
        });
      }, 1000);
      
      return newState;
    });

    setAbilities(prev => ({
      ...prev,
      meteor: { ...prev.meteor, cooldown: prev.meteor.maxCooldown }
    }));
  };

  const castFreeze = () => {
    if (abilities.freeze.cooldown > 0 || gameState.player.mana < abilities.freeze.manaCost || !gameState.gameActive) return;

    setGameState(prev => {
      const newState = { ...prev };
      newState.player.mana -= abilities.freeze.manaCost;
      
      // Freeze all enemies temporarily
      newState.enemies.forEach(enemy => {
        enemy.frozen = abilities.freeze.duration;
        enemy.originalSpeed = enemy.speed;
        enemy.speed = 0;
      });
      
      addFloatingText(newState, newState.player.x, newState.player.y - 30, 'TIME FREEZE!', '#00ffff', 2000);
      createParticles(newState, newState.player.x, newState.player.y, '#00ffff', 15);
      
      return newState;
    });

    setAbilities(prev => ({
      ...prev,
      freeze: { ...prev.freeze, cooldown: prev.freeze.maxCooldown }
    }));
  };

  const togglePause = () => {
    setGameState(prev => ({ ...prev, isPaused: !prev.isPaused }));
  };

  const restartGame = () => {
    // Clear any pending timeouts
    if (spawnTimeoutRef.current) {
      clearTimeout(spawnTimeoutRef.current);
    }
    
    // Cancel current game loop
    if (gameLoopRef.current) {
      cancelAnimationFrame(gameLoopRef.current);
    }
    
    // Reset all state completely
    setGameState(getInitialGameState());
    setAbilities(getInitialAbilities());
    
    // Reset temp effects
    tempEffectsRef.current = { speed: 0, damage: 0, speedMultiplier: 1, damageMultiplier: 1 };
    
    // Reset key states - THIS IS IMPORTANT
    keysRef.current = { w: false, a: false, s: false, d: false };
    
    // Restart the game loop and spawn enemies immediately
    setTimeout(() => {
      // Start with some enemies already in the game
      setGameState(prevState => {
        const newState = { ...prevState };
        // Spawn 3 enemies directly
        for (let i = 0; i < 3; i++) {
          spawnEnemy(newState);
        }
        return newState;
      });
      
      startGameLoop();
    }, 100);
  };

  // Render game
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw background
    const gradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 500);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(1, '#0f0f1e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.3;
    for (let i = 0; i < canvas.width; i += 40) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, canvas.height);
      ctx.stroke();
    }
    for (let i = 0; i < canvas.height; i += 40) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(canvas.width, i);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Draw particles
    gameState.particles.forEach(particle => {
      ctx.fillStyle = particle.color;
      ctx.globalAlpha = particle.life;
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Draw powerups with pulse effect
    gameState.powerups.forEach(powerup => {
      const pulse = Math.sin(Date.now() * 0.008) * 0.2 + 0.8;
      const size = 15 * pulse;
      
      ctx.fillStyle = powerup.color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(powerup.x, powerup.y, size, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
    });
    ctx.globalAlpha = 1;

    // Draw enemies
    gameState.enemies.forEach(enemy => {
      // Flash effect when damaged
      if (enemy.lastDamageTime > 0) {
        ctx.fillStyle = '#ffffff';
      } else {
        ctx.fillStyle = enemy.color;
      }
      
      const size = enemy.size;
      ctx.fillRect(enemy.x - size/2, enemy.y - size/2, size, size);
      
      // Enemy outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(enemy.x - size/2, enemy.y - size/2, size, size);
      
      // Health bar
      const barWidth = size;
      const barHeight = 6;
      const healthPercent = enemy.health / enemy.maxHealth;
      
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(enemy.x - barWidth/2, enemy.y - size/2 - 12, barWidth, barHeight);
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(enemy.x - barWidth/2, enemy.y - size/2 - 12, barWidth * healthPercent, barHeight);
      
      // Health bar outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.strokeRect(enemy.x - barWidth/2, enemy.y - size/2 - 12, barWidth, barHeight);
    });

    // Draw projectiles
    gameState.projectiles.forEach(projectile => {
      ctx.fillStyle = projectile.color;
      ctx.shadowColor = projectile.color;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(projectile.x, projectile.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });

    // Draw player
    ctx.fillStyle = '#0088ff';
    ctx.fillRect(gameState.player.x - 15, gameState.player.y - 15, 30, 30);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(gameState.player.x - 15, gameState.player.y - 15, 30, 30);

    // Draw shield effect
    if (abilities.shield.duration > 0) {
      const shieldAlpha = Math.min(1, abilities.shield.duration / 1000);
      ctx.strokeStyle = `rgba(68, 255, 255, ${shieldAlpha})`;
      ctx.lineWidth = 4;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(gameState.player.x, gameState.player.y, 30, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw floating texts
    gameState.floatingTexts.forEach(text => {
      ctx.font = 'bold 16px Arial';
      ctx.fillStyle = text.color;
      ctx.globalAlpha = text.alpha;
      ctx.textAlign = 'center';
      ctx.fillText(text.text, text.x, text.y);
    });
    ctx.globalAlpha = 1;

    // Draw crosshair at mouse position
    if (mouseRef.current.x && mouseRef.current.y) {
      const range = 200; // Fireball range
      const dx = mouseRef.current.x - gameState.player.x;
      const dy = mouseRef.current.y - gameState.player.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      ctx.strokeStyle = distance <= range ? '#00ff00' : '#ff0000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mouseRef.current.x - 10, mouseRef.current.y);
      ctx.lineTo(mouseRef.current.x + 10, mouseRef.current.y);
      ctx.moveTo(mouseRef.current.x, mouseRef.current.y - 10);
      ctx.lineTo(mouseRef.current.x, mouseRef.current.y + 10);
      ctx.stroke();
      
      // Range circle
      ctx.globalAlpha = 0.2;
      ctx.beginPath();
      ctx.arc(gameState.player.x, gameState.player.y, range, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

  }, [gameState, abilities, mouseRef.current]);

  const formatTime = (ms) => {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const getCooldownPercent = (ability) => {
    return ability.cooldown > 0 ? (ability.cooldown / ability.maxCooldown) * 100 : 0;
  };

  return (
    <div className="ultimate-pixel-game" style={{ 
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', 
      padding: '20px', 
      borderRadius: '15px',
      fontFamily: 'Arial, sans-serif',
      position: 'relative'
    }}>
      {/* Game UI Header */}
      <div style={{ 
        color: 'white', 
        marginBottom: '15px', 
        display: 'grid',
        gridTemplateColumns: '1fr 1fr 1fr',
        gap: '20px',
        background: 'rgba(0,0,0,0.7)',
        padding: '15px',
        borderRadius: '10px'
      }}>
        {/* Player Stats */}
        <div>
          <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>Player Stats</div>
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: '5px' }}>
            <span style={{ width: '60px' }}>Health:</span>
            <div style={{ 
              background: '#333', 
              height: '20px', 
              width: '120px', 
              borderRadius: '10px',
              overflow: 'hidden',
              marginRight: '10px'
            }}>
              <div style={{ 
                background: 'linear-gradient(90deg, #ff0000, #ff6600)',
                height: '100%',
                width: `${(gameState.player.health / gameState.player.maxHealth) * 100}%`,
                transition: 'width 0.3s ease'
              }}></div>
            </div>
            <span>{gameState.player.health}/{gameState.player.maxHealth}</span>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: '5px' }}>
            <span style={{ width: '60px' }}>Mana:</span>
            <div style={{ 
              background: '#333', 
              height: '20px', 
              width: '120px', 
              borderRadius: '10px',
              overflow: 'hidden',
              marginRight: '10px'
            }}>
              <div style={{ 
                background: 'linear-gradient(90deg, #0066ff, #00ccff)',
                height: '100%',
                width: `${(gameState.player.mana / gameState.player.maxMana) * 100}%`,
                transition: 'width 0.3s ease'
              }}></div>
            </div>
            <span>{Math.floor(gameState.player.mana)}/{gameState.player.maxMana}</span>
          </div>
          <div>Level: {gameState.player.level} (XP: {Math.floor(gameState.player.experience)}/{gameState.player.experienceToNext})</div>
        </div>

        {/* Game Stats */}
        <div>
          <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>Game Stats</div>
          <div>Score: {gameState.score.toLocaleString()}</div>
          <div>Wave: {gameState.wave}</div>
          <div>Enemies: {gameState.enemies.length}</div>
          <div>Killed: {gameState.enemiesKilled}</div>
          <div>Time: {formatTime(gameState.gameTime)}</div>
        </div>

        {/* Abilities */}
        <div>
          <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '8px' }}>Abilities</div>
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '5px', fontSize: '12px' }}>
            <div style={{ opacity: abilities.fireball.cooldown > 0 ? 0.5 : 1 }}>
               Fireball (Click)
              {abilities.fireball.cooldown > 0 && (
                <div style={{ background: '#333', height: '4px', borderRadius: '2px' }}>
                  <div style={{ 
                    background: '#ff4400', 
                    height: '100%', 
                    width: `${100 - getCooldownPercent(abilities.fireball)}%`,
                    borderRadius: '2px',
                    transition: 'width 0.1s ease'
                  }}></div>
                </div>
              )}
            </div>
            <div style={{ opacity: abilities.heal.cooldown > 0 ? 0.5 : 1 }}>
               Heal (Space)
              {abilities.heal.cooldown > 0 && (
                <div style={{ background: '#333', height: '4px', borderRadius: '2px' }}>
                  <div style={{ 
                    background: '#00ff00', 
                    height: '100%', 
                    width: `${100 - getCooldownPercent(abilities.heal)}%`,
                    borderRadius: '2px',
                    transition: 'width 0.1s ease'
                  }}></div>
                </div>
              )}
            </div>
            <div style={{ opacity: abilities.lightning.cooldown > 0 ? 0.5 : 1 }}>
               Lightning (Q)
              {abilities.lightning.cooldown > 0 && (
                <div style={{ background: '#333', height: '4px', borderRadius: '2px' }}>
                  <div style={{ 
                    background: '#ffff00', 
                    height: '100%', 
                    width: `${100 - getCooldownPercent(abilities.lightning)}%`,
                    borderRadius: '2px',
                    transition: 'width 0.1s ease'
                  }}></div>
                </div>
              )}
            </div>
            <div style={{ opacity: abilities.shield.cooldown > 0 ? 0.5 : 1 }}>
               Shield (E)
              {abilities.shield.duration > 0 ? (
                <div style={{ color: '#00ffff' }}>Active: {Math.ceil(abilities.shield.duration/1000)}s</div>
              ) : abilities.shield.cooldown > 0 && (
                <div style={{ background: '#333', height: '4px', borderRadius: '2px' }}>
                  <div style={{ 
                    background: '#00ffff', 
                    height: '100%', 
                    width: `${100 - getCooldownPercent(abilities.shield)}%`,
                    borderRadius: '2px',
                    transition: 'width 0.1s ease'
                  }}></div>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Temporary Effects Display */}
      {(tempEffectsRef.current.speed > 0 || tempEffectsRef.current.damage > 0) && (
        <div style={{
          position: 'absolute',
          top: '20px',
          right: '20px',
          background: 'rgba(0,0,0,0.8)',
          color: 'white',
          padding: '10px',
          borderRadius: '5px',
          fontSize: '14px'
        }}>
          <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>Active Effects:</div>
          {tempEffectsRef.current.speed > 0 && (
            <div style={{ color: '#00ff00' }}>
               Speed Boost: {Math.ceil(tempEffectsRef.current.speed/1000)}s
            </div>
          )}
          {tempEffectsRef.current.damage > 0 && (
            <div style={{ color: '#ff8800' }}>
               Damage Boost: {Math.ceil(tempEffectsRef.current.damage/1000)}s
            </div>
          )}
        </div>
      )}

      {/* Game Canvas */}
      <canvas
        ref={canvasRef}
        onMouseMove={handleMouseMove}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        style={{ 
          border: '3px solid #333', 
          borderRadius: '10px',
          cursor: 'crosshair',
          display: 'block',
          boxShadow: '0 0 20px rgba(0,0,0,0.5)'
        }}
      />

      {/* Controls */}
      <div style={{ 
        color: 'white', 
        marginTop: '15px', 
        fontSize: '14px',
        background: 'rgba(0,0,0,0.7)',
        padding: '10px',
        borderRadius: '8px',
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '10px'
      }}>
        <div>
          <strong>Movement:</strong> WASD Keys<br/>
          <strong>Attack:</strong> Click to cast Fireball<br/>
          <strong>Heal:</strong> Space Bar
        </div>
        <div>
          <strong>Lightning:</strong> Q Key<br/>
          <strong>Shield:</strong> E Key<br/>
          <strong>Pause:</strong> P Key
        </div>
      </div>

      {/* Game Over Screen */}
      {!gameState.gameActive && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          color: 'white',
          padding: '40px',
          borderRadius: '15px',
          textAlign: 'center',
          boxShadow: '0 0 30px rgba(0,0,0,0.8)',
          border: '3px solid #fff'
        }}>
          <h2 style={{ fontSize: '32px', marginBottom: '20px', textShadow: '2px 2px 4px rgba(0,0,0,0.5)' }}>
            Game Over!
          </h2>
          <div style={{ fontSize: '18px', marginBottom: '15px' }}>
            <div> Final Score: <strong>{gameState.score.toLocaleString()}</strong></div>
            <div> Wave Reached: <strong>{gameState.wave}</strong></div>
            <div> Level Achieved: <strong>{gameState.player.level}</strong></div>
            <div> Enemies Defeated: <strong>{gameState.enemiesKilled}</strong></div>
            <div> Survival Time: <strong>{formatTime(gameState.gameTime)}</strong></div>
          </div>
          <button 
            onClick={restartGame}
            style={{
              padding: '15px 30px',
              fontSize: '18px',
              background: 'linear-gradient(45deg, #ff6b6b, #ff8e8e)',
              color: 'white',
              border: 'none',
              borderRadius: '25px',
              cursor: 'pointer',
              boxShadow: '0 4px 15px rgba(0,0,0,0.3)',
              transition: 'transform 0.2s ease'
            }}
            onMouseOver={(e) => e.target.style.transform = 'scale(1.05)'}
            onMouseOut={(e) => e.target.style.transform = 'scale(1)'}
          >
             Play Again (R)
          </button>
        </div>
      )}

      {/* Pause Screen */}
      {gameState.isPaused && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'rgba(0,0,0,0.9)',
          color: 'white',
          padding: '30px',
          borderRadius: '15px',
          textAlign: 'center',
          border: '2px solid #fff'
        }}>
          <h3 style={{ fontSize: '24px', marginBottom: '15px' }}> Game Paused</h3>
          <p style={{ fontSize: '16px' }}>Press P to resume</p>
        </div>
      )}
    </div>
  );
};

export default UltimatePixelGame;

---

File: src\WorkProjects.js

import picture from './pictures/porfolio_photos/LinkTrustExample.png';
import picture2 from './pictures/porfolio_photos/LinkTrustExample2.png';
import picture3 from './pictures/porfolio_photos/UserRoles.png';

import React from 'react';

const WorkProjects = () => {
  return (
    <div className="container mt-5" style={{ width: "100vw", minHeight: "100vh", overflow: "auto" }}>
      <h2 className="text-accent mb-4">Work Projects</h2>

      <div className="mt-5 p-3 bg-tertiary shadow">
        <div className="bg-secondary m-3 p-5 shadow">
          {/* GitHub Section */}
          <div className="bg-primary p-4 rounded shadow-sm mb-5">
            <h5 className="text-tertiary mb-3">Connect With Me</h5>
            <div className="d-flex align-items-center">
              <svg height="24" width="24" viewBox="0 0 16 16" className="text-tertiary">
                <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
              </svg>
              <a href="https://github.com/TyShelbyCrenshaw" className="text-accent ms-2 text-decoration-none">github.com/TyShelbyCrenshaw</a>
            </div>
          </div>

          {/* Link Trust Projects Section */}
          <h4 className="text-accent mb-4">Link Trust Projects</h4>

          {/* Project Cards */}
          <div className="project-cards">
            {/* User Roles Project */}
            <div className="bg-tertiary p-4 rounded shadow-sm mb-5">
              <h5 className="text-accent mb-3">User Roles Management System</h5>
              <div className="mb-4">
                <ul className="list-unstyled">
                  <li className="mb-2"> View existing roles organized by type (Client, Partner, Advertiser)</li>
                  <li className="mb-2"> Create new roles for any user type</li>
                  <li className="mb-2"> Edit existing roles' permissions</li>
                  <li className="mb-2"> Delete custom roles (but not default system roles)</li>
                </ul>
              </div>
              <img 
                className="rounded shadow-sm img-fluid mb-2" 
                style={{ width: "100%", maxWidth: "900px" }} 
                src={picture3} 
                alt="User Roles Interface" 
              />
            </div>

            {/* Ad Categories Project */}
            <div className="bg-tertiary p-4 rounded shadow-sm mb-5">
              <h5 className="text-accent mb-3">Ad Categories Management</h5>
              <p className="mb-4">
                A full-stack project implementing CRUD operations for ad categories management.
                Features a comprehensive API backend supporting all frontend operations.
              </p>
              <img 
                className="rounded shadow-sm img-fluid mb-2" 
                style={{ width: "100%", maxWidth: "900px" }} 
                src={picture} 
                alt="Ad Categories Interface" 
              />
            </div>

            {/* Transaction Details Project */}
            <div className="bg-tertiary p-4 rounded shadow-sm mb-5">
              <h5 className="text-accent mb-3">Transaction Details Reporting System</h5>
              <p className="mb-4">
                A comprehensive reporting system featuring:
                <br /> Advanced filtering capabilities
                <br /> CSV export functionality
                <br /> Complex inline editing system
              </p>
              <img 
                className="rounded shadow-sm img-fluid" 
                style={{ width: "100%", maxWidth: "900px" }} 
                src={picture2} 
                alt="Transaction Details Interface" 
              />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default WorkProjects;